import { treeFeature } from "../features/tree/feature";
import { buildStaticInstance } from "./build-static-instance";
import { throwError } from "../utilities/errors";
const verifyFeatures = (features) => {
    var _a;
    const loadedFeatures = features === null || features === void 0 ? void 0 : features.map((feature) => feature.key);
    for (const feature of features !== null && features !== void 0 ? features : []) {
        const missingDependency = (_a = feature.deps) === null || _a === void 0 ? void 0 : _a.find((dep) => !(loadedFeatures === null || loadedFeatures === void 0 ? void 0 : loadedFeatures.includes(dep)));
        if (missingDependency) {
            throw throwError(`${feature.key} needs ${missingDependency}`);
        }
    }
};
// Check all possible pairs and sort the array
const exhaustiveSort = (arr, compareFn) => {
    const n = arr.length;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            if (compareFn(arr[j], arr[i]) < 0) {
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }
    }
    return arr;
};
const compareFeatures = (originalOrder) => (feature1, feature2) => {
    var _a, _b;
    if (feature2.key && ((_a = feature1.overwrites) === null || _a === void 0 ? void 0 : _a.includes(feature2.key))) {
        return 1;
    }
    if (feature1.key && ((_b = feature2.overwrites) === null || _b === void 0 ? void 0 : _b.includes(feature1.key))) {
        return -1;
    }
    return originalOrder.indexOf(feature1) - originalOrder.indexOf(feature2);
};
const sortFeatures = (features = []) => exhaustiveSort(features, compareFeatures(features));
export const createTree = (initialConfig) => {
    var _a, _b, _c, _d;
    const buildInstance = (_a = initialConfig.instanceBuilder) !== null && _a !== void 0 ? _a : buildStaticInstance;
    const additionalFeatures = [
        treeFeature,
        ...sortFeatures(initialConfig.features),
    ];
    verifyFeatures(additionalFeatures);
    const features = [...additionalFeatures];
    const [treeInstance, finalizeTree] = buildInstance(features, "treeInstance", (tree) => ({ tree }));
    let state = additionalFeatures.reduce((acc, feature) => { var _a, _b; return (_b = (_a = feature.getInitialState) === null || _a === void 0 ? void 0 : _a.call(feature, acc, treeInstance)) !== null && _b !== void 0 ? _b : acc; }, (_c = (_b = initialConfig.initialState) !== null && _b !== void 0 ? _b : initialConfig.state) !== null && _c !== void 0 ? _c : {});
    let config = additionalFeatures.reduce((acc, feature) => { var _a, _b; return (_b = (_a = feature.getDefaultConfig) === null || _a === void 0 ? void 0 : _a.call(feature, acc, treeInstance)) !== null && _b !== void 0 ? _b : acc; }, initialConfig);
    const stateHandlerNames = additionalFeatures.reduce((acc, feature) => (Object.assign(Object.assign({}, acc), feature.stateHandlerNames)), {});
    let treeElement;
    const treeDataRef = { current: {} };
    const itemInstancesMap = {};
    let itemInstances = [];
    const itemElementsMap = {};
    const itemDataRefs = {};
    let itemMetaMap = {};
    const hotkeyPresets = {};
    const rebuildItemMeta = () => {
        // TODO can we find a way to only run this for the changed substructure?
        itemInstances = [];
        itemMetaMap = {};
        const [rootInstance, finalizeRootInstance] = buildInstance(features, "itemInstance", (item) => ({ item, tree: treeInstance, itemId: config.rootItemId }));
        finalizeRootInstance();
        itemInstancesMap[config.rootItemId] = rootInstance;
        itemMetaMap[config.rootItemId] = {
            itemId: config.rootItemId,
            index: -1,
            parentId: null,
            level: -1,
            posInSet: 0,
            setSize: 1,
        };
        for (const item of treeInstance.getItemsMeta()) {
            itemMetaMap[item.itemId] = item;
            if (!itemInstancesMap[item.itemId]) {
                const [instance, finalizeInstance] = buildInstance(features, "itemInstance", (instance) => ({
                    item: instance,
                    tree: treeInstance,
                    itemId: item.itemId,
                }));
                finalizeInstance();
                itemInstancesMap[item.itemId] = instance;
                itemInstances.push(instance);
            }
            else {
                itemInstances.push(itemInstancesMap[item.itemId]);
            }
        }
    };
    const eachFeature = (fn) => {
        for (const feature of additionalFeatures) {
            fn(feature);
        }
    };
    const mainFeature = {
        key: "main",
        treeInstance: {
            getState: () => state,
            setState: ({}, updater) => {
                var _a;
                // Not necessary, since I think the subupdate below keeps the state fresh anyways?
                // state = typeof updater === "function" ? updater(state) : updater;
                (_a = config.setState) === null || _a === void 0 ? void 0 : _a.call(config, state); // TODO this cant be right... This doesnt allow external state updates
                // TODO this is never used, remove
            },
            applySubStateUpdate: ({}, stateName, updater) => {
                state[stateName] =
                    typeof updater === "function" ? updater(state[stateName]) : updater;
                const externalStateSetter = config[stateHandlerNames[stateName]];
                externalStateSetter === null || externalStateSetter === void 0 ? void 0 : externalStateSetter(state[stateName]);
            },
            buildItemInstance: ({}, itemId) => {
                const [instance, finalizeInstance] = buildInstance(features, "itemInstance", (instance) => ({
                    item: instance,
                    tree: treeInstance,
                    itemId,
                }));
                finalizeInstance();
                return instance;
            },
            // TODO rebuildSubTree: (itemId: string) => void;
            rebuildTree: () => {
                var _a;
                rebuildItemMeta();
                (_a = config.setState) === null || _a === void 0 ? void 0 : _a.call(config, state);
            },
            getConfig: () => config,
            setConfig: (_, updater) => {
                var _a, _b, _c;
                const newConfig = typeof updater === "function" ? updater(config) : updater;
                const hasChangedExpandedItems = ((_a = newConfig.state) === null || _a === void 0 ? void 0 : _a.expandedItems) &&
                    ((_b = newConfig.state) === null || _b === void 0 ? void 0 : _b.expandedItems) !== state.expandedItems;
                config = newConfig;
                if (newConfig.state) {
                    state = Object.assign(Object.assign({}, state), newConfig.state);
                }
                if (hasChangedExpandedItems) {
                    // if expanded items where changed from the outside
                    rebuildItemMeta();
                    (_c = config.setState) === null || _c === void 0 ? void 0 : _c.call(config, state);
                }
            },
            getItemInstance: ({}, itemId) => itemInstancesMap[itemId],
            getItems: () => itemInstances,
            registerElement: ({}, element) => {
                if (treeElement === element) {
                    return;
                }
                if (treeElement && !element) {
                    eachFeature((feature) => { var _a; return (_a = feature.onTreeUnmount) === null || _a === void 0 ? void 0 : _a.call(feature, treeInstance, treeElement); });
                }
                else if (!treeElement && element) {
                    eachFeature((feature) => { var _a; return (_a = feature.onTreeMount) === null || _a === void 0 ? void 0 : _a.call(feature, treeInstance, element); });
                }
                treeElement = element;
            },
            getElement: () => treeElement,
            getDataRef: () => treeDataRef,
            getHotkeyPresets: () => hotkeyPresets,
        },
        itemInstance: {
            registerElement: ({ itemId, item }, element) => {
                if (itemElementsMap[itemId] === element) {
                    return;
                }
                const oldElement = itemElementsMap[itemId];
                if (oldElement && !element) {
                    eachFeature((feature) => { var _a; return (_a = feature.onItemUnmount) === null || _a === void 0 ? void 0 : _a.call(feature, item, oldElement, treeInstance); });
                }
                else if (!oldElement && element) {
                    eachFeature((feature) => { var _a; return (_a = feature.onItemMount) === null || _a === void 0 ? void 0 : _a.call(feature, item, element, treeInstance); });
                }
                itemElementsMap[itemId] = element;
            },
            getElement: ({ itemId }) => itemElementsMap[itemId],
            // eslint-disable-next-line no-return-assign
            getDataRef: ({ itemId }) => { var _a; return ((_a = itemDataRefs[itemId]) !== null && _a !== void 0 ? _a : (itemDataRefs[itemId] = { current: {} })); },
            getItemMeta: ({ itemId }) => itemMetaMap[itemId],
        },
    };
    features.unshift(mainFeature);
    for (const feature of features) {
        Object.assign(hotkeyPresets, (_d = feature.hotkeys) !== null && _d !== void 0 ? _d : {});
    }
    finalizeTree();
    return treeInstance;
};
