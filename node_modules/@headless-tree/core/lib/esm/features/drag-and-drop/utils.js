export var ItemDropCategory;
(function (ItemDropCategory) {
    ItemDropCategory[ItemDropCategory["Item"] = 0] = "Item";
    ItemDropCategory[ItemDropCategory["ExpandedFolder"] = 1] = "ExpandedFolder";
    ItemDropCategory[ItemDropCategory["LastInGroup"] = 2] = "LastInGroup";
})(ItemDropCategory || (ItemDropCategory = {}));
var PlacementType;
(function (PlacementType) {
    PlacementType[PlacementType["ReorderAbove"] = 0] = "ReorderAbove";
    PlacementType[PlacementType["ReorderBelow"] = 1] = "ReorderBelow";
    PlacementType[PlacementType["MakeChild"] = 2] = "MakeChild";
    PlacementType[PlacementType["Reparent"] = 3] = "Reparent";
})(PlacementType || (PlacementType = {}));
export const isOrderedDragTarget = (dragTarget) => "childIndex" in dragTarget;
export const canDrop = (dataTransfer, target, tree) => {
    var _a, _b, _c;
    const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
    const config = tree.getConfig();
    if (draggedItems && !((_c = (_b = config.canDrop) === null || _b === void 0 ? void 0 : _b.call(config, draggedItems, target)) !== null && _c !== void 0 ? _c : true)) {
        return false;
    }
    if (draggedItems &&
        draggedItems.some((draggedItem) => target.item.getId() === draggedItem.getId() ||
            target.item.isDescendentOf(draggedItem.getId()))) {
        return false;
    }
    if (!draggedItems &&
        dataTransfer &&
        config.canDropForeignDragObject &&
        !config.canDropForeignDragObject(dataTransfer, target)) {
        return false;
    }
    return true;
};
export const getItemDropCategory = (item) => {
    if (item.isExpanded()) {
        return ItemDropCategory.ExpandedFolder;
    }
    const parent = item.getParent();
    if (parent && item.getIndexInParent() === item.getItemMeta().setSize - 1) {
        return ItemDropCategory.LastInGroup;
    }
    return ItemDropCategory.Item;
};
export const getInsertionIndex = (children, childIndex, draggedItems) => {
    var _a;
    const numberOfDragItemsBeforeTarget = (_a = children
        .slice(0, childIndex)
        .reduce((counter, child) => child && (draggedItems === null || draggedItems === void 0 ? void 0 : draggedItems.some((i) => i.getId() === child.getId()))
        ? ++counter
        : counter, 0)) !== null && _a !== void 0 ? _a : 0;
    return childIndex - numberOfDragItemsBeforeTarget;
};
const getTargetPlacement = (e, item, tree, canMakeChild) => {
    var _a, _b, _c, _d, _e;
    const config = tree.getConfig();
    if (!config.canReorder) {
        return canMakeChild
            ? { type: PlacementType.MakeChild }
            : { type: PlacementType.ReorderBelow };
    }
    const bb = (_a = item.getElement()) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
    const topPercent = bb ? (e.clientY - bb.top) / bb.height : 0.5;
    const leftPixels = bb ? e.clientX - bb.left : 0;
    const targetDropCategory = getItemDropCategory(item);
    const reorderAreaPercentage = !canMakeChild
        ? 0.5
        : (_b = config.reorderAreaPercentage) !== null && _b !== void 0 ? _b : 0.3;
    const indent = (_c = config.indent) !== null && _c !== void 0 ? _c : 20;
    const makeChildType = canMakeChild
        ? PlacementType.MakeChild
        : PlacementType.ReorderBelow;
    if (targetDropCategory === ItemDropCategory.ExpandedFolder) {
        if (topPercent < reorderAreaPercentage) {
            return { type: PlacementType.ReorderAbove };
        }
        return { type: makeChildType };
    }
    if (targetDropCategory === ItemDropCategory.LastInGroup) {
        if (leftPixels < item.getItemMeta().level * indent) {
            if (topPercent < 0.5) {
                return { type: PlacementType.ReorderAbove };
            }
            const minLevel = (_e = (_d = item.getItemBelow()) === null || _d === void 0 ? void 0 : _d.getItemMeta().level) !== null && _e !== void 0 ? _e : 0;
            return {
                type: PlacementType.Reparent,
                reparentLevel: Math.max(minLevel, Math.floor(leftPixels / indent)),
            };
        }
        // if not at left of item area, treat as if it was a normal item
    }
    // targetDropCategory === ItemDropCategory.Item
    if (topPercent < reorderAreaPercentage) {
        return { type: PlacementType.ReorderAbove };
    }
    if (topPercent > 1 - reorderAreaPercentage) {
        return { type: PlacementType.ReorderBelow };
    }
    return { type: makeChildType };
};
export const getDragCode = (e, item, tree) => {
    const placement = getTargetPlacement(e, item, tree, true);
    return [
        item.getId(),
        placement.type,
        placement.type === PlacementType.Reparent ? placement.reparentLevel : 0,
    ].join("__");
};
const getNthParent = (item, n) => {
    if (n === item.getItemMeta().level) {
        return item;
    }
    return getNthParent(item.getParent(), n);
};
/** @param item refers to the bottom-most item of the container, at which bottom is being reparented on (e.g. root-1-2-6)  */
export const getReparentTarget = (item, reparentLevel, draggedItems) => {
    const itemMeta = item.getItemMeta();
    const reparentedTarget = getNthParent(item, reparentLevel - 1);
    const targetItemAbove = getNthParent(item, reparentLevel); // .getItemBelow()!;
    const targetIndex = targetItemAbove.getIndexInParent() + 1;
    return {
        item: reparentedTarget,
        childIndex: targetIndex,
        insertionIndex: getInsertionIndex(reparentedTarget.getChildren(), targetIndex, draggedItems),
        dragLineIndex: itemMeta.index + 1,
        dragLineLevel: reparentLevel,
    };
};
export const getDragTarget = (e, item, tree, canReorder = tree.getConfig().canReorder) => {
    var _a;
    const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
    const itemMeta = item.getItemMeta();
    const parent = item.getParent();
    const itemTarget = { item };
    const parentTarget = parent ? { item: parent } : null;
    const canBecomeSibling = parentTarget && canDrop(e.dataTransfer, parentTarget, tree);
    const canMakeChild = canDrop(e.dataTransfer, itemTarget, tree);
    const placement = getTargetPlacement(e, item, tree, canMakeChild);
    if (!canReorder &&
        parent &&
        canBecomeSibling &&
        placement.type !== PlacementType.MakeChild) {
        return parentTarget;
    }
    if (!canReorder && parent && !canBecomeSibling) {
        // TODO! this breaks in story DND/Can Drop. Maybe move this logic into a composable DragTargetStrategy[] ?
        return getDragTarget(e, parent, tree, false);
    }
    if (!parent) {
        // Shouldn't happen, but if dropped "next" to root item, just drop it inside
        return itemTarget;
    }
    if (placement.type === PlacementType.MakeChild) {
        return itemTarget;
    }
    if (!canBecomeSibling) {
        return getDragTarget(e, parent, tree, false);
    }
    if (placement.type === PlacementType.Reparent) {
        return getReparentTarget(item, placement.reparentLevel, draggedItems);
    }
    const maybeAddOneForBelow = placement.type === PlacementType.ReorderAbove ? 0 : 1;
    const childIndex = item.getIndexInParent() + maybeAddOneForBelow;
    return {
        item: parent,
        dragLineIndex: itemMeta.index + maybeAddOneForBelow,
        dragLineLevel: itemMeta.level,
        childIndex,
        // TODO performance could be improved by computing this only when dragcode changed
        insertionIndex: getInsertionIndex(parent.getChildren(), childIndex, draggedItems),
    };
};
