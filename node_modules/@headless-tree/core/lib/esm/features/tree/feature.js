var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { makeStateUpdater, poll } from "../../utils";
import { logWarning } from "../../utilities/errors";
export const treeFeature = {
    key: "tree",
    getInitialState: (initialState) => (Object.assign({ expandedItems: [], focusedItem: null }, initialState)),
    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setExpandedItems: makeStateUpdater("expandedItems", tree), setFocusedItem: makeStateUpdater("focusedItem", tree) }, defaultConfig)),
    stateHandlerNames: {
        expandedItems: "setExpandedItems",
        focusedItem: "setFocusedItem",
    },
    treeInstance: {
        getItemsMeta: ({ tree }) => {
            const { rootItemId } = tree.getConfig();
            const { expandedItems } = tree.getState();
            const flatItems = [];
            const expandedItemsSet = new Set(expandedItems); // TODO support setting state expandedItems as set instead of array
            const recursiveAdd = (itemId, path, level, setSize, posInSet) => {
                var _a;
                if (path.includes(itemId)) {
                    logWarning(`Circular reference for ${path.join(".")}`);
                    return;
                }
                flatItems.push({
                    itemId,
                    level,
                    index: flatItems.length,
                    parentId: path.at(-1),
                    setSize,
                    posInSet,
                });
                if (expandedItemsSet.has(itemId)) {
                    const children = (_a = tree.retrieveChildrenIds(itemId)) !== null && _a !== void 0 ? _a : [];
                    let i = 0;
                    for (const childId of children) {
                        recursiveAdd(childId, path.concat(itemId), level + 1, children.length, i++);
                    }
                }
            };
            const children = tree.retrieveChildrenIds(rootItemId);
            let i = 0;
            for (const itemId of children) {
                recursiveAdd(itemId, [rootItemId], 0, children.length, i++);
            }
            return flatItems;
        },
        getFocusedItem: ({ tree }) => {
            var _a, _b;
            return ((_b = tree.getItemInstance((_a = tree.getState().focusedItem) !== null && _a !== void 0 ? _a : "")) !== null && _b !== void 0 ? _b : tree.getItems()[0]);
        },
        getRootItem: ({ tree }) => {
            const { rootItemId } = tree.getConfig();
            return tree.getItemInstance(rootItemId);
        },
        focusNextItem: ({ tree }) => {
            var _a;
            const focused = tree.getFocusedItem().getItemMeta();
            if (!focused)
                return;
            const nextIndex = Math.min(focused.index + 1, tree.getItems().length - 1);
            (_a = tree.getItems()[nextIndex]) === null || _a === void 0 ? void 0 : _a.setFocused();
        },
        focusPreviousItem: ({ tree }) => {
            var _a;
            const focused = tree.getFocusedItem().getItemMeta();
            if (!focused)
                return;
            const nextIndex = Math.max(focused.index - 1, 0);
            (_a = tree.getItems()[nextIndex]) === null || _a === void 0 ? void 0 : _a.setFocused();
        },
        updateDomFocus: ({ tree }) => {
            // Required because if the state is managed outside in react, the state only updated during next render
            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                var _a, _b;
                const focusedItem = tree.getFocusedItem();
                (_b = (_a = tree.getConfig()).scrollToItem) === null || _b === void 0 ? void 0 : _b.call(_a, focusedItem);
                yield poll(() => focusedItem.getElement() !== null, 20);
                const focusedElement = focusedItem.getElement();
                if (!focusedElement)
                    return;
                focusedElement.focus();
            }));
        },
        getContainerProps: ({ prev, tree }, treeLabel) => (Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { role: "tree", "aria-label": treeLabel !== null && treeLabel !== void 0 ? treeLabel : "", ref: tree.registerElement })),
        // relevant for hotkeys of this feature
        isSearchOpen: () => false,
    },
    itemInstance: {
        scrollTo: (_a, scrollIntoViewArg_1) => __awaiter(void 0, [_a, scrollIntoViewArg_1], void 0, function* ({ tree, item }, scrollIntoViewArg) {
            var _b, _c, _d;
            (_c = (_b = tree.getConfig()).scrollToItem) === null || _c === void 0 ? void 0 : _c.call(_b, item);
            yield poll(() => item.getElement() !== null, 20);
            (_d = item.getElement()) === null || _d === void 0 ? void 0 : _d.scrollIntoView(scrollIntoViewArg);
        }),
        getId: ({ itemId }) => itemId,
        getKey: ({ itemId }) => itemId, // TODO apply to all stories to use
        getProps: ({ item, prev }) => {
            const itemMeta = item.getItemMeta();
            return Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { ref: item.registerElement, role: "treeitem", "aria-setsize": itemMeta.setSize, "aria-posinset": itemMeta.posInSet, "aria-selected": "false", "aria-label": item.getItemName(), "aria-level": itemMeta.level, tabIndex: item.isFocused() ? 0 : -1, onClick: (e) => {
                    item.setFocused();
                    item.primaryAction();
                    if (e.ctrlKey || e.shiftKey || e.metaKey) {
                        return;
                    }
                    if (!item.isFolder()) {
                        return;
                    }
                    if (item.isExpanded()) {
                        item.collapse();
                    }
                    else {
                        item.expand();
                    }
                } });
        },
        expand: ({ tree, item, itemId }) => {
            var _a;
            if (!item.isFolder()) {
                return;
            }
            if ((_a = tree.getState().loadingItemChildrens) === null || _a === void 0 ? void 0 : _a.includes(itemId)) {
                return;
            }
            tree.applySubStateUpdate("expandedItems", (expandedItems) => [
                ...expandedItems,
                itemId,
            ]);
            tree.rebuildTree();
        },
        collapse: ({ tree, item, itemId }) => {
            if (!item.isFolder()) {
                return;
            }
            tree.applySubStateUpdate("expandedItems", (expandedItems) => expandedItems.filter((id) => id !== itemId));
            tree.rebuildTree();
        },
        getItemData: ({ tree, itemId }) => tree.retrieveItemData(itemId),
        equals: ({ item }, other) => item.getId() === (other === null || other === void 0 ? void 0 : other.getId()),
        isExpanded: ({ tree, itemId }) => tree.getState().expandedItems.includes(itemId),
        isDescendentOf: ({ item }, parentId) => {
            const parent = item.getParent();
            return Boolean((parent === null || parent === void 0 ? void 0 : parent.getId()) === parentId || (parent === null || parent === void 0 ? void 0 : parent.isDescendentOf(parentId)));
        },
        isFocused: ({ tree, item, itemId }) => tree.getState().focusedItem === itemId ||
            (tree.getState().focusedItem === null && item.getItemMeta().index === 0),
        isFolder: ({ tree, item }) => item.getItemMeta().level === -1 ||
            tree.getConfig().isItemFolder(item),
        getItemName: ({ tree, item }) => {
            const config = tree.getConfig();
            return config.getItemName(item);
        },
        setFocused: ({ tree, itemId }) => {
            tree.applySubStateUpdate("focusedItem", itemId);
        },
        primaryAction: ({ tree, item }) => { var _a, _b; return (_b = (_a = tree.getConfig()).onPrimaryAction) === null || _b === void 0 ? void 0 : _b.call(_a, item); },
        getParent: ({ tree, item }) => item.getItemMeta().parentId
            ? tree.getItemInstance(item.getItemMeta().parentId)
            : undefined,
        getIndexInParent: ({ item }) => item.getItemMeta().posInSet,
        getChildren: ({ tree, itemId }) => tree.retrieveChildrenIds(itemId).map((id) => tree.getItemInstance(id)),
        getTree: ({ tree }) => tree,
        getItemAbove: ({ tree, item }) => tree.getItems()[item.getItemMeta().index - 1],
        getItemBelow: ({ tree, item }) => tree.getItems()[item.getItemMeta().index + 1],
    },
    hotkeys: {
        focusNextItem: {
            hotkey: "ArrowDown",
            canRepeat: true,
            preventDefault: true,
            isEnabled: (tree) => { var _a, _b; return !((_b = (_a = tree.isSearchOpen) === null || _a === void 0 ? void 0 : _a.call(tree)) !== null && _b !== void 0 ? _b : false) && !tree.getState().dnd; }, // TODO what happens when the feature doesnt exist? proxy method still claims to exist
            handler: (e, tree) => {
                tree.focusNextItem();
                tree.updateDomFocus();
            },
        },
        focusPreviousItem: {
            hotkey: "ArrowUp",
            canRepeat: true,
            preventDefault: true,
            isEnabled: (tree) => { var _a, _b; return !((_b = (_a = tree.isSearchOpen) === null || _a === void 0 ? void 0 : _a.call(tree)) !== null && _b !== void 0 ? _b : false) && !tree.getState().dnd; },
            handler: (e, tree) => {
                tree.focusPreviousItem();
                tree.updateDomFocus();
            },
        },
        expandOrDown: {
            hotkey: "ArrowRight",
            canRepeat: true,
            handler: (e, tree) => {
                const item = tree.getFocusedItem();
                if (item.isExpanded() || !item.isFolder()) {
                    tree.focusNextItem();
                    tree.updateDomFocus();
                }
                else {
                    item.expand();
                }
            },
        },
        collapseOrUp: {
            hotkey: "ArrowLeft",
            canRepeat: true,
            handler: (e, tree) => {
                var _a;
                const item = tree.getFocusedItem();
                if ((!item.isExpanded() || !item.isFolder()) &&
                    item.getItemMeta().level !== 0) {
                    (_a = item.getParent()) === null || _a === void 0 ? void 0 : _a.setFocused();
                    tree.updateDomFocus();
                }
                else {
                    item.collapse();
                }
            },
        },
        focusFirstItem: {
            hotkey: "Home",
            handler: (e, tree) => {
                var _a;
                (_a = tree.getItems()[0]) === null || _a === void 0 ? void 0 : _a.setFocused();
                tree.updateDomFocus();
            },
        },
        focusLastItem: {
            hotkey: "End",
            handler: (e, tree) => {
                var _a;
                (_a = tree.getItems()[tree.getItems().length - 1]) === null || _a === void 0 ? void 0 : _a.setFocused();
                tree.updateDomFocus();
            },
        },
    },
};
