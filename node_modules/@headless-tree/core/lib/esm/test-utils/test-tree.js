var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/* eslint-disable import/no-extraneous-dependencies */
import { beforeEach, describe, vi } from "vitest";
import { createTree } from "../core/create-tree";
import { TestTreeDo } from "./test-tree-do";
import { TestTreeExpect } from "./test-tree-expect";
import { syncDataLoaderFeature } from "../features/sync-data-loader/feature";
import { asyncDataLoaderFeature } from "../features/async-data-loader/feature";
import { buildProxiedInstance } from "../core/build-proxified-instance";
vi.useFakeTimers({ shouldAdvanceTime: true });
export class TestTree {
    forSuits(runSuite) {
        describe.for([
            this.suits.sync(),
            this.suits.async(),
            this.suits.proxifiedSync(),
            this.suits.proxifiedAsync(),
        ])("$title", ({ tree }) => {
            tree.resetBeforeEach();
            runSuite(tree);
        });
    }
    get instance() {
        if (!this.treeInstance) {
            this.treeInstance = createTree(this.config);
            this.treeInstance.rebuildTree();
        }
        return this.treeInstance;
    }
    constructor(config) {
        this.config = config;
        this.do = new TestTreeDo(this);
        this.expect = new TestTreeExpect(this);
        this.treeInstance = null;
        this.asyncDataLoaderImp = {
            getItem: (id) => __awaiter(this, void 0, void 0, function* () {
                yield new Promise((r) => {
                    r.debugName = `Loading getItem ${id}`;
                    TestTree.asyncLoaderResolvers.push(r);
                });
                return id;
            }),
            getChildren: (id) => __awaiter(this, void 0, void 0, function* () {
                yield new Promise((r) => {
                    r.debugName = `Loading getChildren ${id}`;
                    TestTree.asyncLoaderResolvers.push(r);
                });
                return [`${id}1`, `${id}2`, `${id}3`, `${id}4`];
            }),
        };
        this.suits = {
            sync: () => ({
                tree: this.withFeatures(syncDataLoaderFeature),
                title: "Synchronous Data Loader",
            }),
            async: () => ({
                tree: this.withFeatures(asyncDataLoaderFeature).with({
                    dataLoader: this.asyncDataLoaderImp,
                }),
                title: "Asynchronous Data Loader",
            }),
            proxifiedSync: () => ({
                tree: this.withFeatures(syncDataLoaderFeature).with({
                    instanceBuilder: buildProxiedInstance,
                }),
                title: "Proxified Synchronous Data Loader",
            }),
            proxifiedAsync: () => ({
                tree: this.withFeatures(asyncDataLoaderFeature).with({
                    instanceBuilder: buildProxiedInstance,
                }),
                title: "Proxified Asynchronous Data Loader",
            }),
        };
    }
    static resolveAsyncLoaders() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            do {
                (_a = TestTree.asyncLoaderResolvers.shift()) === null || _a === void 0 ? void 0 : _a();
                yield new Promise((r) => {
                    setTimeout(r);
                });
            } while (TestTree.asyncLoaderResolvers.length);
        });
    }
    resolveAsyncVisibleItems() {
        return __awaiter(this, void 0, void 0, function* () {
            this.instance.getItems();
            yield TestTree.resolveAsyncLoaders();
            this.instance.getItems().forEach((i) => i.getItemName());
            yield TestTree.resolveAsyncLoaders();
        });
    }
    static default(config) {
        return new TestTree(Object.assign({ rootItemId: "x", createLoadingItemData: () => "loading", dataLoader: {
                getItem: (id) => id,
                getChildren: (id) => [`${id}1`, `${id}2`, `${id}3`, `${id}4`],
            }, getItemName: (item) => item.getItemData(), indent: 20, isItemFolder: (item) => item.getItemMeta().level < 2, initialState: {
                expandedItems: ["x1", "x11"],
            }, features: [] }, config));
    }
    with(config) {
        return new TestTree(Object.assign(Object.assign({}, this.config), config));
    }
    resetBeforeEach() {
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            yield this.createTestCaseTree();
        }));
    }
    createTestCaseTree() {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            vi.clearAllMocks();
            // trigger instance creation
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            this.instance;
            yield this.resolveAsyncVisibleItems();
            return this;
        });
    }
    withFeatures(...features) {
        var _a;
        return this.with({
            features: [...((_a = this.config.features) !== null && _a !== void 0 ? _a : []), ...features],
        });
    }
    mockedHandler(handlerName) {
        var _a;
        const mock = vi.fn();
        if (this.treeInstance) {
            (_a = this.treeInstance) === null || _a === void 0 ? void 0 : _a.setConfig((prev) => (Object.assign(Object.assign({}, prev), { [handlerName]: mock })));
        }
        else {
            this.config[handlerName] = mock;
        }
        return mock;
    }
    item(itemId) {
        return this.instance.getItemInstance(itemId);
    }
    reset() {
        this.treeInstance = null;
        TestTree.asyncLoaderResolvers = [];
    }
    debug() {
        console.log(this.instance
            .getItems()
            .map((item) => [
            "  ".repeat(item.getItemMeta().level),
            '"',
            item.getItemName(),
            '"',
        ].join(""))
            .join("\n"));
    }
    setElementBoundingBox(itemId, bb = {
        left: 0,
        width: 100,
        top: 0,
        height: 20,
    }) {
        this.instance.registerElement({
            getBoundingClientRect: () => ({
                left: 0,
                width: 100,
                top: 0,
                height: 10000,
            }),
        });
        this.instance.getItemInstance(itemId).registerElement({
            getBoundingClientRect: () => bb,
        });
    }
    static dragEvent(clientX = 1000, clientY = 0) {
        return {
            preventDefault: vi.fn(),
            stopPropagation: vi.fn(),
            dataTransfer: {
                setData: vi.fn(),
                getData: vi.fn(),
                dropEffect: "unchaged-from-test",
            },
            clientX,
            clientY,
        };
    }
    createTopDragEvent(indent = 0) {
        return TestTree.dragEvent(indent * 20, 1);
    }
    createBottomDragEvent(indent = 0) {
        return TestTree.dragEvent(indent * 20, 19);
    }
}
TestTree.asyncLoaderResolvers = [];
