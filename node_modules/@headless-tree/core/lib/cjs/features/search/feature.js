"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchFeature = void 0;
const utils_1 = require("../../utils");
exports.searchFeature = {
    key: "search",
    getInitialState: (initialState) => (Object.assign({ search: null }, initialState)),
    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setSearch: (0, utils_1.makeStateUpdater)("search", tree), isSearchMatchingItem: (search, item) => search.length > 0 &&
            item.getItemName().toLowerCase().includes(search.toLowerCase()) }, defaultConfig)),
    stateHandlerNames: {
        search: "setSearch",
    },
    treeInstance: {
        setSearch: ({ tree }, search) => {
            var _a;
            tree.applySubStateUpdate("search", search);
            (_a = tree
                .getItems()
                .find((item) => { var _a, _b; return (_b = (_a = tree.getConfig()).isSearchMatchingItem) === null || _b === void 0 ? void 0 : _b.call(_a, tree.getSearchValue(), item); })) === null || _a === void 0 ? void 0 : _a.setFocused();
        },
        openSearch: ({ tree }, initialValue = "") => {
            var _a, _b;
            tree.setSearch(initialValue);
            (_b = (_a = tree.getConfig()).onOpenSearch) === null || _b === void 0 ? void 0 : _b.call(_a);
            setTimeout(() => {
                var _a;
                (_a = tree.getDataRef().current.searchInput) === null || _a === void 0 ? void 0 : _a.focus();
            });
        },
        closeSearch: ({ tree }) => {
            var _a, _b;
            tree.setSearch(null);
            (_b = (_a = tree.getConfig()).onCloseSearch) === null || _b === void 0 ? void 0 : _b.call(_a);
            tree.updateDomFocus();
        },
        isSearchOpen: ({ tree }) => tree.getState().search !== null,
        getSearchValue: ({ tree }) => tree.getState().search || "",
        registerSearchInputElement: ({ tree }, element) => {
            const dataRef = tree.getDataRef();
            dataRef.current.searchInput = element;
            if (element && dataRef.current.keydownHandler) {
                element.addEventListener("keydown", dataRef.current.keydownHandler);
            }
        },
        getSearchInputElement: ({ tree }) => { var _a; return (_a = tree.getDataRef().current.searchInput) !== null && _a !== void 0 ? _a : null; },
        // TODO memoize with propMemoizationFeature
        getSearchInputElementProps: ({ tree }) => ({
            value: tree.getSearchValue(),
            onChange: (e) => tree.setSearch(e.target.value),
            onBlur: () => tree.closeSearch(),
            ref: tree.registerSearchInputElement,
        }),
        getSearchMatchingItems: (0, utils_1.memo)(({ tree }) => [
            tree.getSearchValue(),
            tree.getItems(),
            tree.getConfig().isSearchMatchingItem,
        ], (search, items, isSearchMatchingItem) => items.filter((item) => search && (isSearchMatchingItem === null || isSearchMatchingItem === void 0 ? void 0 : isSearchMatchingItem(search, item)))),
    },
    itemInstance: {
        isMatchingSearch: ({ tree, item }) => tree.getSearchMatchingItems().some((i) => i.getId() === item.getId()),
    },
    hotkeys: {
        openSearch: {
            hotkey: "LetterOrNumber",
            preventDefault: true, // TODO make true default
            isEnabled: (tree) => !tree.isSearchOpen(),
            handler: (e, tree) => {
                e.stopPropagation();
                tree.openSearch(e.key);
            },
        },
        closeSearch: {
            // TODO allow multiple, i.e. Enter
            hotkey: "Escape",
            allowWhenInputFocused: true,
            isEnabled: (tree) => tree.isSearchOpen(),
            handler: (e, tree) => {
                tree.closeSearch();
            },
        },
        submitSearch: {
            hotkey: "Enter",
            allowWhenInputFocused: true,
            isEnabled: (tree) => tree.isSearchOpen(),
            handler: (e, tree) => {
                tree.closeSearch();
                tree.setSelectedItems([tree.getFocusedItem().getId()]);
            },
        },
        nextSearchItem: {
            hotkey: "ArrowDown",
            allowWhenInputFocused: true,
            canRepeat: true,
            isEnabled: (tree) => tree.isSearchOpen(),
            handler: (e, tree) => {
                const focusItem = tree
                    .getSearchMatchingItems()
                    .find((item) => item.getItemMeta().index >
                    tree.getFocusedItem().getItemMeta().index);
                focusItem === null || focusItem === void 0 ? void 0 : focusItem.setFocused();
                focusItem === null || focusItem === void 0 ? void 0 : focusItem.scrollTo({ block: "nearest", inline: "nearest" });
            },
        },
        previousSearchItem: {
            hotkey: "ArrowUp",
            allowWhenInputFocused: true,
            canRepeat: true,
            isEnabled: (tree) => tree.isSearchOpen(),
            handler: (e, tree) => {
                const focusItem = [...tree.getSearchMatchingItems()]
                    .reverse()
                    .find((item) => item.getItemMeta().index <
                    tree.getFocusedItem().getItemMeta().index);
                focusItem === null || focusItem === void 0 ? void 0 : focusItem.setFocused();
                focusItem === null || focusItem === void 0 ? void 0 : focusItem.scrollTo({ block: "nearest", inline: "nearest" });
            },
        },
    },
};
