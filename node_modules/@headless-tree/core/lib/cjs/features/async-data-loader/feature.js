"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncDataLoaderFeature = void 0;
const utils_1 = require("../../utils");
const getDataRef = (tree) => {
    var _a, _b;
    var _c, _d;
    const dataRef = tree.getDataRef();
    (_a = (_c = dataRef.current).itemData) !== null && _a !== void 0 ? _a : (_c.itemData = {});
    (_b = (_d = dataRef.current).childrenIds) !== null && _b !== void 0 ? _b : (_d.childrenIds = {});
    return dataRef;
};
const loadItemData = (tree, itemId) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const config = tree.getConfig();
    const dataRef = getDataRef(tree);
    const item = yield config.dataLoader.getItem(itemId);
    dataRef.current.itemData[itemId] = item;
    (_a = config.onLoadedItem) === null || _a === void 0 ? void 0 : _a.call(config, itemId, item);
    tree.applySubStateUpdate("loadingItemData", (loadingItemData) => loadingItemData.filter((id) => id !== itemId));
    return item;
});
const loadChildrenIds = (tree, itemId) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const config = tree.getConfig();
    const dataRef = getDataRef(tree);
    let childrenIds;
    if ("getChildrenWithData" in config.dataLoader) {
        const children = yield config.dataLoader.getChildrenWithData(itemId);
        childrenIds = children.map((c) => c.id);
        dataRef.current.childrenIds[itemId] = childrenIds;
        children.forEach(({ id, data }) => {
            var _a;
            dataRef.current.itemData[id] = data;
            (_a = config.onLoadedItem) === null || _a === void 0 ? void 0 : _a.call(config, id, data);
        });
        (_a = config.onLoadedChildren) === null || _a === void 0 ? void 0 : _a.call(config, itemId, childrenIds);
        tree.rebuildTree();
        tree.applySubStateUpdate("loadingItemData", (loadingItemData) => loadingItemData.filter((id) => !childrenIds.includes(id)));
    }
    else {
        childrenIds = yield config.dataLoader.getChildren(itemId);
        dataRef.current.childrenIds[itemId] = childrenIds;
        (_b = config.onLoadedChildren) === null || _b === void 0 ? void 0 : _b.call(config, itemId, childrenIds);
        tree.rebuildTree();
    }
    tree.applySubStateUpdate("loadingItemChildrens", (loadingItemChildrens) => loadingItemChildrens.filter((id) => id !== itemId));
    return childrenIds;
});
exports.asyncDataLoaderFeature = {
    key: "async-data-loader",
    getInitialState: (initialState) => (Object.assign({ loadingItemData: [], loadingItemChildrens: [] }, initialState)),
    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setLoadingItemData: (0, utils_1.makeStateUpdater)("loadingItemData", tree), setLoadingItemChildrens: (0, utils_1.makeStateUpdater)("loadingItemChildrens", tree) }, defaultConfig)),
    stateHandlerNames: {
        loadingItemData: "setLoadingItemData",
        loadingItemChildrens: "setLoadingItemChildrens",
    },
    treeInstance: {
        waitForItemDataLoaded: ({ tree }, itemId) => tree.loadItemData(itemId),
        waitForItemChildrenLoaded: ({ tree }, itemId) => tree.loadChildrenIds(itemId),
        loadItemData: (_a, itemId_1) => __awaiter(void 0, [_a, itemId_1], void 0, function* ({ tree }, itemId) {
            var _b;
            return ((_b = getDataRef(tree).current.itemData[itemId]) !== null && _b !== void 0 ? _b : (yield loadItemData(tree, itemId)));
        }),
        loadChildrenIds: (_a, itemId_1) => __awaiter(void 0, [_a, itemId_1], void 0, function* ({ tree }, itemId) {
            var _b;
            return ((_b = getDataRef(tree).current.childrenIds[itemId]) !== null && _b !== void 0 ? _b : (yield loadChildrenIds(tree, itemId)));
        }),
        retrieveItemData: ({ tree }, itemId, skipFetch = false) => {
            var _a, _b;
            const config = tree.getConfig();
            const dataRef = getDataRef(tree);
            if (dataRef.current.itemData[itemId]) {
                return dataRef.current.itemData[itemId];
            }
            if (!tree.getState().loadingItemData.includes(itemId) && !skipFetch) {
                tree.applySubStateUpdate("loadingItemData", (loadingItemData) => [
                    ...loadingItemData,
                    itemId,
                ]);
                loadItemData(tree, itemId);
            }
            return (_b = (_a = config.createLoadingItemData) === null || _a === void 0 ? void 0 : _a.call(config)) !== null && _b !== void 0 ? _b : null;
        },
        retrieveChildrenIds: ({ tree }, itemId, skipFetch = false) => {
            const dataRef = getDataRef(tree);
            if (dataRef.current.childrenIds[itemId]) {
                return dataRef.current.childrenIds[itemId];
            }
            if (tree.getState().loadingItemChildrens.includes(itemId) || skipFetch) {
                return [];
            }
            tree.applySubStateUpdate("loadingItemChildrens", (loadingItemChildrens) => [...loadingItemChildrens, itemId]);
            loadChildrenIds(tree, itemId);
            return [];
        },
    },
    itemInstance: {
        isLoading: ({ tree, item }) => tree.getState().loadingItemData.includes(item.getItemMeta().itemId) ||
            tree.getState().loadingItemChildrens.includes(item.getItemMeta().itemId),
        invalidateItemData: (_a, optimistic_1) => __awaiter(void 0, [_a, optimistic_1], void 0, function* ({ tree, itemId }, optimistic) {
            var _b;
            if (!optimistic) {
                (_b = getDataRef(tree).current.itemData) === null || _b === void 0 ? true : delete _b[itemId];
                tree.applySubStateUpdate("loadingItemData", (loadingItemData) => [
                    ...loadingItemData,
                    itemId,
                ]);
            }
            yield loadItemData(tree, itemId);
        }),
        invalidateChildrenIds: (_a, optimistic_1) => __awaiter(void 0, [_a, optimistic_1], void 0, function* ({ tree, itemId }, optimistic) {
            var _b;
            if (!optimistic) {
                (_b = getDataRef(tree).current.childrenIds) === null || _b === void 0 ? true : delete _b[itemId];
                tree.applySubStateUpdate("loadingItemChildrens", (loadingItemChildrens) => [...loadingItemChildrens, itemId]);
            }
            yield loadChildrenIds(tree, itemId);
        }),
        updateCachedChildrenIds: ({ tree, itemId }, childrenIds) => {
            const dataRef = tree.getDataRef();
            dataRef.current.childrenIds[itemId] = childrenIds;
            tree.rebuildTree();
        },
    },
};
