"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.keyboardDragAndDropFeature = void 0;
const utils_1 = require("../drag-and-drop/utils");
const utils_2 = require("../../utils");
const types_1 = require("./types");
const getNextDragTarget = (tree, isUp, dragTarget) => {
    var _a, _b, _c, _d;
    const direction = isUp ? 0 : 1;
    const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
    // currently hovering between items
    if ((0, utils_1.isOrderedDragTarget)(dragTarget)) {
        const parent = dragTarget.item.getParent();
        const targetedItem = tree.getItems()[dragTarget.dragLineIndex - 1]; // item above dragline
        const targetCategory = targetedItem
            ? (0, utils_1.getItemDropCategory)(targetedItem)
            : utils_1.ItemDropCategory.Item;
        const maxLevel = (_b = targetedItem === null || targetedItem === void 0 ? void 0 : targetedItem.getItemMeta().level) !== null && _b !== void 0 ? _b : 0;
        const minLevel = (_d = (_c = targetedItem === null || targetedItem === void 0 ? void 0 : targetedItem.getItemBelow()) === null || _c === void 0 ? void 0 : _c.getItemMeta().level) !== null && _d !== void 0 ? _d : 0;
        // reparenting
        if (targetCategory === utils_1.ItemDropCategory.LastInGroup) {
            if (isUp && dragTarget.dragLineLevel < maxLevel) {
                return (0, utils_1.getReparentTarget)(targetedItem, dragTarget.dragLineLevel + 1, draggedItems);
            }
            if (!isUp && dragTarget.dragLineLevel > minLevel && parent) {
                return (0, utils_1.getReparentTarget)(targetedItem, dragTarget.dragLineLevel - 1, draggedItems);
            }
        }
        const newIndex = dragTarget.dragLineIndex - 1 + direction;
        const item = tree.getItems()[newIndex];
        return item ? { item } : undefined;
    }
    // moving upwards outside of an open folder
    const targetingExpandedFolder = (0, utils_1.getItemDropCategory)(dragTarget.item) === utils_1.ItemDropCategory.ExpandedFolder;
    if (targetingExpandedFolder && !isUp) {
        return {
            item: dragTarget.item,
            childIndex: 0,
            insertionIndex: (0, utils_1.getInsertionIndex)(dragTarget.item.getChildren(), 0, draggedItems),
            dragLineIndex: dragTarget.item.getItemMeta().index + direction,
            dragLineLevel: dragTarget.item.getItemMeta().level + 1,
        };
    }
    // currently hovering over item
    const childIndex = dragTarget.item.getIndexInParent() + direction;
    return {
        item: dragTarget.item.getParent(),
        childIndex,
        insertionIndex: (0, utils_1.getInsertionIndex)(dragTarget.item.getParent().getChildren(), childIndex, draggedItems),
        dragLineIndex: dragTarget.item.getItemMeta().index + direction,
        dragLineLevel: dragTarget.item.getItemMeta().level,
    };
};
const getNextValidDragTarget = (tree, isUp, previousTarget) => {
    var _a, _b;
    if (previousTarget === void 0) { previousTarget = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.dragTarget; }
    if (!previousTarget)
        return undefined;
    const nextTarget = getNextDragTarget(tree, isUp, previousTarget);
    const dataTransfer = (_b = tree.getDataRef().current.kDndDataTransfer) !== null && _b !== void 0 ? _b : null;
    if (!nextTarget)
        return undefined;
    if ((0, utils_1.canDrop)(dataTransfer, nextTarget, tree)) {
        return nextTarget;
    }
    return getNextValidDragTarget(tree, isUp, nextTarget);
};
const updateScroll = (tree) => {
    const state = tree.getState().dnd;
    if (!(state === null || state === void 0 ? void 0 : state.dragTarget) || (0, utils_1.isOrderedDragTarget)(state.dragTarget))
        return;
    state.dragTarget.item.scrollTo({ block: "nearest", inline: "nearest" });
};
const initiateDrag = (tree, draggedItems, dataTransfer) => {
    var _a, _b;
    const focusedItem = tree.getFocusedItem();
    const { canDrag } = tree.getConfig();
    if (draggedItems && canDrag && !canDrag(draggedItems)) {
        return;
    }
    if (draggedItems) {
        tree.applySubStateUpdate("dnd", { draggedItems });
        // getNextValidDragTarget->canDrop needs the draggedItems in state
        (_b = (_a = tree.getConfig()).onStartKeyboardDrag) === null || _b === void 0 ? void 0 : _b.call(_a, draggedItems);
    }
    else if (dataTransfer) {
        tree.getDataRef().current.kDndDataTransfer = dataTransfer;
    }
    const dragTarget = getNextValidDragTarget(tree, false, {
        item: focusedItem,
    });
    if (!dragTarget)
        return;
    tree.applySubStateUpdate("dnd", {
        draggedItems,
        dragTarget,
    });
    tree.applySubStateUpdate("assistiveDndState", types_1.AssistiveDndState.Started);
    updateScroll(tree);
};
const moveDragPosition = (tree, isUp) => {
    var _a;
    const dragTarget = getNextValidDragTarget(tree, isUp);
    if (!dragTarget)
        return;
    tree.applySubStateUpdate("dnd", {
        draggedItems: (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems,
        dragTarget,
    });
    tree.applySubStateUpdate("assistiveDndState", types_1.AssistiveDndState.Dragging);
    if (!(0, utils_1.isOrderedDragTarget)(dragTarget)) {
        dragTarget.item.setFocused();
    }
    updateScroll(tree);
};
exports.keyboardDragAndDropFeature = {
    key: "keyboard-drag-and-drop",
    deps: ["drag-and-drop"],
    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setAssistiveDndState: (0, utils_2.makeStateUpdater)("assistiveDndState", tree) }, defaultConfig)),
    stateHandlerNames: {
        assistiveDndState: "setAssistiveDndState",
    },
    treeInstance: {
        startKeyboardDrag: ({ tree }, draggedItems) => {
            initiateDrag(tree, draggedItems, undefined);
        },
        startKeyboardDragOnForeignObject: ({ tree }, dataTransfer) => {
            initiateDrag(tree, undefined, dataTransfer);
        },
        stopKeyboardDrag: ({ tree }) => {
            tree.getDataRef().current.kDndDataTransfer = undefined;
            tree.applySubStateUpdate("dnd", null);
            tree.applySubStateUpdate("assistiveDndState", types_1.AssistiveDndState.None);
        },
    },
    hotkeys: {
        startDrag: {
            hotkey: "Control+Shift+KeyD",
            preventDefault: true,
            isEnabled: (tree) => !tree.getState().dnd,
            handler: (_, tree) => {
                tree.startKeyboardDrag(tree.getSelectedItems());
            },
        },
        dragUp: {
            hotkey: "ArrowUp",
            preventDefault: true,
            isEnabled: (tree) => !!tree.getState().dnd,
            handler: (_, tree) => {
                moveDragPosition(tree, true);
            },
        },
        dragDown: {
            hotkey: "ArrowDown",
            preventDefault: true,
            isEnabled: (tree) => !!tree.getState().dnd,
            handler: (_, tree) => {
                moveDragPosition(tree, false);
            },
        },
        cancelDrag: {
            hotkey: "Escape",
            isEnabled: (tree) => !!tree.getState().dnd,
            handler: (_, tree) => {
                tree.stopKeyboardDrag();
            },
        },
        completeDrag: {
            hotkey: "Enter",
            preventDefault: true,
            isEnabled: (tree) => !!tree.getState().dnd,
            handler: (e, tree) => __awaiter(void 0, void 0, void 0, function* () {
                var _a, _b, _c, _d;
                e.stopPropagation();
                // TODO copied from keyboard onDrop, unify them
                const dataRef = tree.getDataRef();
                const target = tree.getDragTarget();
                const dataTransfer = (_a = dataRef.current.kDndDataTransfer) !== null && _a !== void 0 ? _a : null;
                if (!target || !(0, utils_1.canDrop)(dataTransfer, target, tree)) {
                    return;
                }
                const config = tree.getConfig();
                const draggedItems = (_b = tree.getState().dnd) === null || _b === void 0 ? void 0 : _b.draggedItems;
                dataRef.current.lastDragCode = undefined;
                tree.applySubStateUpdate("dnd", null);
                if (draggedItems) {
                    yield ((_c = config.onDrop) === null || _c === void 0 ? void 0 : _c.call(config, draggedItems, target));
                    tree.getItemInstance(draggedItems[0].getId()).setFocused();
                }
                else if (dataTransfer) {
                    yield ((_d = config.onDropForeignDragObject) === null || _d === void 0 ? void 0 : _d.call(config, dataTransfer, target));
                }
                tree.applySubStateUpdate("assistiveDndState", types_1.AssistiveDndState.Completed);
            }),
        },
    },
};
