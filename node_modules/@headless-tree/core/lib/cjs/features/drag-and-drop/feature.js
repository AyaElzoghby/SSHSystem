"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dragAndDropFeature = void 0;
const utils_1 = require("./utils");
const utils_2 = require("../../utils");
exports.dragAndDropFeature = {
    key: "drag-and-drop",
    deps: ["selection"],
    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ canDrop: (_, target) => target.item.isFolder(), canDropForeignDragObject: () => false, setDndState: (0, utils_2.makeStateUpdater)("dnd", tree), canReorder: true }, defaultConfig)),
    stateHandlerNames: {
        dnd: "setDndState",
    },
    treeInstance: {
        getDragTarget: ({ tree }) => {
            var _a, _b;
            return (_b = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.dragTarget) !== null && _b !== void 0 ? _b : null;
        },
        getDragLineData: ({ tree }) => {
            var _a, _b, _c, _d, _e, _f;
            const target = tree.getDragTarget();
            const indent = ((_a = target === null || target === void 0 ? void 0 : target.item.getItemMeta().level) !== null && _a !== void 0 ? _a : 0) + 1;
            const treeBb = (_b = tree.getElement()) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
            if (!target || !treeBb || !(0, utils_1.isOrderedDragTarget)(target))
                return null;
            const leftOffset = target.dragLineLevel * ((_c = tree.getConfig().indent) !== null && _c !== void 0 ? _c : 1);
            const targetItem = tree.getItems()[target.dragLineIndex];
            if (!targetItem) {
                const bb = (_e = (_d = tree
                    .getItems()[target.dragLineIndex - 1]) === null || _d === void 0 ? void 0 : _d.getElement()) === null || _e === void 0 ? void 0 : _e.getBoundingClientRect();
                if (bb) {
                    return {
                        indent,
                        top: bb.bottom - treeBb.top,
                        left: bb.left + leftOffset - treeBb.left,
                        width: bb.width - leftOffset,
                    };
                }
            }
            const bb = (_f = targetItem.getElement()) === null || _f === void 0 ? void 0 : _f.getBoundingClientRect();
            if (bb) {
                return {
                    indent,
                    top: bb.top - treeBb.top,
                    left: bb.left + leftOffset - treeBb.left,
                    width: bb.width - leftOffset,
                };
            }
            return null;
        },
        getDragLineStyle: ({ tree }, topOffset = -1, leftOffset = -8) => {
            const dragLine = tree.getDragLineData();
            return dragLine
                ? {
                    position: "absolute",
                    top: `${dragLine.top + topOffset}px`,
                    left: `${dragLine.left + leftOffset}px`,
                    width: `${dragLine.width - leftOffset}px`,
                    pointerEvents: "none", // important to prevent capturing drag events
                }
                : { display: "none" };
        },
        getContainerProps: ({ prev, tree }, treeLabel) => {
            const prevProps = prev === null || prev === void 0 ? void 0 : prev(treeLabel);
            return Object.assign(Object.assign({}, prevProps), { onDragOver: (e) => {
                    e.preventDefault();
                }, onDrop: (e) => __awaiter(void 0, void 0, void 0, function* () {
                    var _a, _b, _c;
                    // TODO merge implementation with itemInstance.onDrop
                    const dataRef = tree.getDataRef();
                    const target = { item: tree.getRootItem() };
                    if (!(0, utils_1.canDrop)(e.dataTransfer, target, tree)) {
                        return;
                    }
                    e.preventDefault();
                    const config = tree.getConfig();
                    const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
                    dataRef.current.lastDragCode = undefined;
                    tree.applySubStateUpdate("dnd", null);
                    if (draggedItems) {
                        yield ((_b = config.onDrop) === null || _b === void 0 ? void 0 : _b.call(config, draggedItems, target));
                    }
                    else if (e.dataTransfer) {
                        yield ((_c = config.onDropForeignDragObject) === null || _c === void 0 ? void 0 : _c.call(config, e.dataTransfer, target));
                    }
                }), style: Object.assign(Object.assign({}, prevProps === null || prevProps === void 0 ? void 0 : prevProps.style), { position: "relative" }) });
        },
    },
    itemInstance: {
        getProps: ({ tree, item, prev }) => (Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { draggable: true, onDragEnter: (e) => e.preventDefault(), onDragStart: (e) => {
                var _a, _b, _c, _d;
                const selectedItems = tree.getSelectedItems();
                const items = selectedItems.includes(item) ? selectedItems : [item];
                const config = tree.getConfig();
                if (!selectedItems.includes(item)) {
                    tree.setSelectedItems([item.getItemMeta().itemId]);
                }
                if (!((_b = (_a = config.canDrag) === null || _a === void 0 ? void 0 : _a.call(config, items)) !== null && _b !== void 0 ? _b : true)) {
                    e.preventDefault();
                    return;
                }
                if (config.setDragImage) {
                    const { imgElement, xOffset, yOffset } = config.setDragImage(items);
                    (_c = e.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(imgElement, xOffset !== null && xOffset !== void 0 ? xOffset : 0, yOffset !== null && yOffset !== void 0 ? yOffset : 0);
                }
                if (config.createForeignDragObject) {
                    const { format, data } = config.createForeignDragObject(items);
                    (_d = e.dataTransfer) === null || _d === void 0 ? void 0 : _d.setData(format, data);
                }
                tree.applySubStateUpdate("dnd", {
                    draggedItems: items,
                    draggingOverItem: tree.getFocusedItem(),
                });
            }, onDragOver: (e) => {
                var _a, _b, _c;
                const dataRef = tree.getDataRef();
                const nextDragCode = (0, utils_1.getDragCode)(e, item, tree);
                if (nextDragCode === dataRef.current.lastDragCode) {
                    if (dataRef.current.lastAllowDrop) {
                        e.preventDefault();
                    }
                    return;
                }
                dataRef.current.lastDragCode = nextDragCode;
                const target = (0, utils_1.getDragTarget)(e, item, tree);
                if (!((_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems) &&
                    (!e.dataTransfer ||
                        !((_c = (_b = tree
                            .getConfig()).canDropForeignDragObject) === null || _c === void 0 ? void 0 : _c.call(_b, e.dataTransfer, target)))) {
                    dataRef.current.lastAllowDrop = false;
                    return;
                }
                if (!(0, utils_1.canDrop)(e.dataTransfer, target, tree)) {
                    dataRef.current.lastAllowDrop = false;
                    return;
                }
                tree.applySubStateUpdate("dnd", (state) => (Object.assign(Object.assign({}, state), { dragTarget: target, draggingOverItem: item })));
                dataRef.current.lastAllowDrop = true;
                e.preventDefault();
            }, onDragLeave: () => {
                const dataRef = tree.getDataRef();
                dataRef.current.lastDragCode = "no-drag";
                tree.applySubStateUpdate("dnd", (state) => (Object.assign(Object.assign({}, state), { draggingOverItem: undefined, dragTarget: undefined })));
            }, onDragEnd: (e) => {
                var _a, _b, _c, _d;
                const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
                tree.applySubStateUpdate("dnd", null);
                if (((_b = e.dataTransfer) === null || _b === void 0 ? void 0 : _b.dropEffect) === "none" || !draggedItems) {
                    return;
                }
                (_d = (_c = tree.getConfig()).onCompleteForeignDrop) === null || _d === void 0 ? void 0 : _d.call(_c, draggedItems);
            }, onDrop: (e) => __awaiter(void 0, void 0, void 0, function* () {
                var _a, _b, _c;
                e.stopPropagation();
                const dataRef = tree.getDataRef();
                const target = (0, utils_1.getDragTarget)(e, item, tree);
                if (!(0, utils_1.canDrop)(e.dataTransfer, target, tree)) {
                    return;
                }
                e.preventDefault();
                const config = tree.getConfig();
                const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
                dataRef.current.lastDragCode = undefined;
                tree.applySubStateUpdate("dnd", null);
                if (draggedItems) {
                    yield ((_b = config.onDrop) === null || _b === void 0 ? void 0 : _b.call(config, draggedItems, target));
                }
                else if (e.dataTransfer) {
                    yield ((_c = config.onDropForeignDragObject) === null || _c === void 0 ? void 0 : _c.call(config, e.dataTransfer, target));
                }
            }) })),
        isDragTarget: ({ tree, item }) => {
            const target = tree.getDragTarget();
            return target ? target.item.getId() === item.getId() : false;
        },
        isDragTargetAbove: ({ tree, item }) => {
            const target = tree.getDragTarget();
            if (!target ||
                !(0, utils_1.isOrderedDragTarget)(target) ||
                target.item !== item.getParent())
                return false;
            return target.childIndex === item.getItemMeta().posInSet;
        },
        isDragTargetBelow: ({ tree, item }) => {
            const target = tree.getDragTarget();
            if (!target ||
                !(0, utils_1.isOrderedDragTarget)(target) ||
                target.item !== item.getParent())
                return false;
            return target.childIndex - 1 === item.getItemMeta().posInSet;
        },
        isDraggingOver: ({ tree, item }) => {
            var _a, _b;
            return ((_b = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggingOverItem) === null || _b === void 0 ? void 0 : _b.getId()) === item.getId();
        },
    },
};
