"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildProxiedInstance = void 0;
const errors_1 = require("../utilities/errors");
const noop = () => { };
const findPrevInstanceMethod = (features, instanceType, methodKey, featureSearchIndex) => {
    var _a;
    for (let i = featureSearchIndex; i >= 0; i--) {
        const feature = features[i];
        const itemInstanceMethod = (_a = feature[instanceType]) === null || _a === void 0 ? void 0 : _a[methodKey];
        if (itemInstanceMethod) {
            return i;
        }
    }
    return null;
};
const invokeInstanceMethod = (features, instanceType, opts, methodKey, featureIndex, args) => {
    var _a;
    const prevIndex = findPrevInstanceMethod(features, instanceType, methodKey, featureIndex - 1);
    const itemInstanceMethod = (_a = features[featureIndex][instanceType]) === null || _a === void 0 ? void 0 : _a[methodKey];
    return itemInstanceMethod(Object.assign(Object.assign({}, opts), { prev: prevIndex !== null
            ? (...newArgs) => invokeInstanceMethod(features, instanceType, opts, methodKey, prevIndex, newArgs)
            : null }), ...args);
};
const buildProxiedInstance = (features, instanceType, buildOpts) => {
    // demo with prototypes: https://jsfiddle.net/bgenc58r/
    const opts = {};
    const item = new Proxy({}, {
        has(target, key) {
            if (typeof key === "symbol") {
                return false;
            }
            if (key === "toJSON") {
                return false;
            }
            const hasInstanceMethod = findPrevInstanceMethod(features, instanceType, key, features.length - 1);
            return Boolean(hasInstanceMethod);
        },
        get(target, key) {
            if (typeof key === "symbol") {
                return undefined;
            }
            if (key === "toJSON") {
                return {};
            }
            return (...args) => {
                const featureIndex = findPrevInstanceMethod(features, instanceType, key, features.length - 1);
                if (featureIndex === null) {
                    throw (0, errors_1.throwError)(`feature missing for method ${key}`);
                }
                return invokeInstanceMethod(features, instanceType, opts, key, featureIndex, args);
            };
        },
    });
    Object.assign(opts, buildOpts(item));
    return [item, noop];
};
exports.buildProxiedInstance = buildProxiedInstance;
