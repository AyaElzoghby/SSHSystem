"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestTreeDo = void 0;
const vitest_1 = require("vitest");
const test_tree_1 = require("./test-tree");
class TestTreeDo {
    itemInstance(itemId) {
        return this.tree.instance.getItemInstance(itemId);
    }
    itemProps(itemId) {
        return this.itemInstance(itemId).getProps();
    }
    constructor(tree) {
        this.tree = tree;
    }
    selectItem(id) {
        this.itemProps(id).onClick({});
    }
    shiftSelectItem(id) {
        this.itemProps(id).onClick({ shiftKey: true });
    }
    ctrlSelectItem(id) {
        this.itemProps(id).onClick({ ctrlKey: true });
    }
    ctrlShiftSelectItem(id) {
        this.itemProps(id).onClick({ shiftKey: true, ctrlKey: true });
    }
    selectMultiple(...ids) {
        ids.forEach((id) => this.ctrlSelectItem(id));
    }
    hotkey(hotkey, e = {}) {
        var _a, _b;
        const hotkeyConfig = Object.assign(Object.assign({}, this.tree.instance.getHotkeyPresets()[hotkey]), (_a = this.tree.instance.getConfig().hotkeys) === null || _a === void 0 ? void 0 : _a[hotkey]);
        if (hotkeyConfig.isEnabled &&
            !((_b = hotkeyConfig.isEnabled) === null || _b === void 0 ? void 0 : _b.call(hotkeyConfig, this.tree.instance))) {
            throw new Error(`Hotkey "${hotkey}" is disabled`);
        }
        if (!hotkeyConfig.handler) {
            throw new Error(`Hotkey "${hotkey}" has no handler`);
        }
        hotkeyConfig.handler(Object.assign(Object.assign({}, e), { stopPropagation: () => { }, preventDefault: () => { } }), this.tree.instance);
    }
    startDrag(itemId, event) {
        if (!this.itemProps(itemId).draggable) {
            throw new Error(`Can't drag item ${itemId}, has attribute draggable=false`);
        }
        const e = event !== null && event !== void 0 ? event : test_tree_1.TestTree.dragEvent();
        this.itemProps(itemId).onDragStart(e);
        return e;
    }
    dragOver(itemId, event) {
        const e = event !== null && event !== void 0 ? event : test_tree_1.TestTree.dragEvent();
        e.preventDefault.mockClear();
        this.itemProps(itemId).onDragOver(e);
        this.itemProps(itemId).onDragOver(e);
        this.itemProps(itemId).onDragOver(e);
        (0, vitest_1.expect)(e.preventDefault).toBeCalledTimes(3);
        this.consistentCalls(e.preventDefault);
        this.consistentCalls(e.stopPropagation);
        return e;
    }
    dragOverNotAllowed(itemId, event) {
        const e = event !== null && event !== void 0 ? event : test_tree_1.TestTree.dragEvent();
        e.preventDefault.mockClear();
        this.itemProps(itemId).onDragOver(e);
        this.itemProps(itemId).onDragOver(e);
        this.itemProps(itemId).onDragOver(e);
        (0, vitest_1.expect)(e.preventDefault).toBeCalledTimes(0);
        this.consistentCalls(e.preventDefault);
        this.consistentCalls(e.stopPropagation);
        return e;
    }
    dragLeave(itemId) {
        this.itemProps(itemId).onDragLeave({});
    }
    dragEnd(itemId, event) {
        const e = event !== null && event !== void 0 ? event : test_tree_1.TestTree.dragEvent();
        this.itemProps(itemId).onDragEnd(e);
        return e;
    }
    drop(itemId, event) {
        return __awaiter(this, void 0, void 0, function* () {
            const e = event !== null && event !== void 0 ? event : test_tree_1.TestTree.dragEvent();
            yield this.itemProps(itemId).onDrop(e);
            return e;
        });
    }
    dragOverAndDrop(itemId, event) {
        return __awaiter(this, void 0, void 0, function* () {
            const e = event !== null && event !== void 0 ? event : test_tree_1.TestTree.dragEvent();
            this.dragOver(itemId, e);
            return this.drop(itemId, e);
        });
    }
    consistentCalls(fn) {
        if (!vitest_1.vi.isMockFunction(fn)) {
            throw new Error("fn is not a mock");
        }
        (0, vitest_1.expect)(fn.mock.calls.length, "function called inconsistent times").toBeOneOf([0, 3]);
        (0, vitest_1.expect)(new Set(fn.mock.calls.map((call) => call.join("__"))).size, "function called with inconsistent parameters").toBeOneOf([0, 1]);
    }
}
exports.TestTreeDo = TestTreeDo;
