// node_modules/@headless-tree/core/lib/esm/utils.js
var memo = (deps, fn) => {
  let value;
  let oldDeps = null;
  return (...a) => {
    const newDeps = deps(...a);
    if (!value) {
      value = fn(...newDeps);
      oldDeps = newDeps;
      return value;
    }
    const match = oldDeps && oldDeps.length === newDeps.length && !oldDeps.some((dep, i) => dep !== newDeps[i]);
    if (match) {
      return value;
    }
    value = fn(...newDeps);
    oldDeps = newDeps;
    return value;
  };
};
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return Object.assign(Object.assign({}, old), { [key]: functionalUpdate(updater, old[key]) });
    });
  };
}
var poll = (fn, interval = 100, timeout = 1e3) => new Promise((resolve) => {
  let clear;
  const i = setInterval(() => {
    if (fn()) {
      resolve();
      clearInterval(i);
      clearTimeout(clear);
    }
  }, interval);
  clear = setTimeout(() => {
    clearInterval(i);
  }, timeout);
});

// node_modules/@headless-tree/core/lib/esm/utilities/errors.js
var prefix = "Headless Tree: ";
var throwError = (message) => Error(prefix + message);
var logWarning = (message) => console.warn(prefix + message);

// node_modules/@headless-tree/core/lib/esm/features/tree/feature.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var treeFeature = {
  key: "tree",
  getInitialState: (initialState) => Object.assign({ expandedItems: [], focusedItem: null }, initialState),
  getDefaultConfig: (defaultConfig, tree) => Object.assign({ setExpandedItems: makeStateUpdater("expandedItems", tree), setFocusedItem: makeStateUpdater("focusedItem", tree) }, defaultConfig),
  stateHandlerNames: {
    expandedItems: "setExpandedItems",
    focusedItem: "setFocusedItem"
  },
  treeInstance: {
    getItemsMeta: ({ tree }) => {
      const { rootItemId } = tree.getConfig();
      const { expandedItems } = tree.getState();
      const flatItems = [];
      const expandedItemsSet = new Set(expandedItems);
      const recursiveAdd = (itemId, path, level, setSize, posInSet) => {
        var _a;
        if (path.includes(itemId)) {
          logWarning(`Circular reference for ${path.join(".")}`);
          return;
        }
        flatItems.push({
          itemId,
          level,
          index: flatItems.length,
          parentId: path.at(-1),
          setSize,
          posInSet
        });
        if (expandedItemsSet.has(itemId)) {
          const children2 = (_a = tree.retrieveChildrenIds(itemId)) !== null && _a !== void 0 ? _a : [];
          let i2 = 0;
          for (const childId of children2) {
            recursiveAdd(childId, path.concat(itemId), level + 1, children2.length, i2++);
          }
        }
      };
      const children = tree.retrieveChildrenIds(rootItemId);
      let i = 0;
      for (const itemId of children) {
        recursiveAdd(itemId, [rootItemId], 0, children.length, i++);
      }
      return flatItems;
    },
    getFocusedItem: ({ tree }) => {
      var _a, _b;
      return (_b = tree.getItemInstance((_a = tree.getState().focusedItem) !== null && _a !== void 0 ? _a : "")) !== null && _b !== void 0 ? _b : tree.getItems()[0];
    },
    getRootItem: ({ tree }) => {
      const { rootItemId } = tree.getConfig();
      return tree.getItemInstance(rootItemId);
    },
    focusNextItem: ({ tree }) => {
      var _a;
      const focused = tree.getFocusedItem().getItemMeta();
      if (!focused)
        return;
      const nextIndex = Math.min(focused.index + 1, tree.getItems().length - 1);
      (_a = tree.getItems()[nextIndex]) === null || _a === void 0 ? void 0 : _a.setFocused();
    },
    focusPreviousItem: ({ tree }) => {
      var _a;
      const focused = tree.getFocusedItem().getItemMeta();
      if (!focused)
        return;
      const nextIndex = Math.max(focused.index - 1, 0);
      (_a = tree.getItems()[nextIndex]) === null || _a === void 0 ? void 0 : _a.setFocused();
    },
    updateDomFocus: ({ tree }) => {
      setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b;
        const focusedItem = tree.getFocusedItem();
        (_b = (_a = tree.getConfig()).scrollToItem) === null || _b === void 0 ? void 0 : _b.call(_a, focusedItem);
        yield poll(() => focusedItem.getElement() !== null, 20);
        const focusedElement = focusedItem.getElement();
        if (!focusedElement)
          return;
        focusedElement.focus();
      }));
    },
    getContainerProps: ({ prev, tree }, treeLabel) => Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { role: "tree", "aria-label": treeLabel !== null && treeLabel !== void 0 ? treeLabel : "", ref: tree.registerElement }),
    // relevant for hotkeys of this feature
    isSearchOpen: () => false
  },
  itemInstance: {
    scrollTo: (_a, scrollIntoViewArg_1) => __awaiter(void 0, [_a, scrollIntoViewArg_1], void 0, function* ({ tree, item }, scrollIntoViewArg) {
      var _b, _c, _d;
      (_c = (_b = tree.getConfig()).scrollToItem) === null || _c === void 0 ? void 0 : _c.call(_b, item);
      yield poll(() => item.getElement() !== null, 20);
      (_d = item.getElement()) === null || _d === void 0 ? void 0 : _d.scrollIntoView(scrollIntoViewArg);
    }),
    getId: ({ itemId }) => itemId,
    getKey: ({ itemId }) => itemId,
    // TODO apply to all stories to use
    getProps: ({ item, prev }) => {
      const itemMeta = item.getItemMeta();
      return Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { ref: item.registerElement, role: "treeitem", "aria-setsize": itemMeta.setSize, "aria-posinset": itemMeta.posInSet, "aria-selected": "false", "aria-label": item.getItemName(), "aria-level": itemMeta.level, tabIndex: item.isFocused() ? 0 : -1, onClick: (e) => {
        item.setFocused();
        item.primaryAction();
        if (e.ctrlKey || e.shiftKey || e.metaKey) {
          return;
        }
        if (!item.isFolder()) {
          return;
        }
        if (item.isExpanded()) {
          item.collapse();
        } else {
          item.expand();
        }
      } });
    },
    expand: ({ tree, item, itemId }) => {
      var _a;
      if (!item.isFolder()) {
        return;
      }
      if ((_a = tree.getState().loadingItemChildrens) === null || _a === void 0 ? void 0 : _a.includes(itemId)) {
        return;
      }
      tree.applySubStateUpdate("expandedItems", (expandedItems) => [
        ...expandedItems,
        itemId
      ]);
      tree.rebuildTree();
    },
    collapse: ({ tree, item, itemId }) => {
      if (!item.isFolder()) {
        return;
      }
      tree.applySubStateUpdate("expandedItems", (expandedItems) => expandedItems.filter((id) => id !== itemId));
      tree.rebuildTree();
    },
    getItemData: ({ tree, itemId }) => tree.retrieveItemData(itemId),
    equals: ({ item }, other) => item.getId() === (other === null || other === void 0 ? void 0 : other.getId()),
    isExpanded: ({ tree, itemId }) => tree.getState().expandedItems.includes(itemId),
    isDescendentOf: ({ item }, parentId) => {
      const parent = item.getParent();
      return Boolean((parent === null || parent === void 0 ? void 0 : parent.getId()) === parentId || (parent === null || parent === void 0 ? void 0 : parent.isDescendentOf(parentId)));
    },
    isFocused: ({ tree, item, itemId }) => tree.getState().focusedItem === itemId || tree.getState().focusedItem === null && item.getItemMeta().index === 0,
    isFolder: ({ tree, item }) => item.getItemMeta().level === -1 || tree.getConfig().isItemFolder(item),
    getItemName: ({ tree, item }) => {
      const config = tree.getConfig();
      return config.getItemName(item);
    },
    setFocused: ({ tree, itemId }) => {
      tree.applySubStateUpdate("focusedItem", itemId);
    },
    primaryAction: ({ tree, item }) => {
      var _a, _b;
      return (_b = (_a = tree.getConfig()).onPrimaryAction) === null || _b === void 0 ? void 0 : _b.call(_a, item);
    },
    getParent: ({ tree, item }) => item.getItemMeta().parentId ? tree.getItemInstance(item.getItemMeta().parentId) : void 0,
    getIndexInParent: ({ item }) => item.getItemMeta().posInSet,
    getChildren: ({ tree, itemId }) => tree.retrieveChildrenIds(itemId).map((id) => tree.getItemInstance(id)),
    getTree: ({ tree }) => tree,
    getItemAbove: ({ tree, item }) => tree.getItems()[item.getItemMeta().index - 1],
    getItemBelow: ({ tree, item }) => tree.getItems()[item.getItemMeta().index + 1]
  },
  hotkeys: {
    focusNextItem: {
      hotkey: "ArrowDown",
      canRepeat: true,
      preventDefault: true,
      isEnabled: (tree) => {
        var _a, _b;
        return !((_b = (_a = tree.isSearchOpen) === null || _a === void 0 ? void 0 : _a.call(tree)) !== null && _b !== void 0 ? _b : false) && !tree.getState().dnd;
      },
      // TODO what happens when the feature doesnt exist? proxy method still claims to exist
      handler: (e, tree) => {
        tree.focusNextItem();
        tree.updateDomFocus();
      }
    },
    focusPreviousItem: {
      hotkey: "ArrowUp",
      canRepeat: true,
      preventDefault: true,
      isEnabled: (tree) => {
        var _a, _b;
        return !((_b = (_a = tree.isSearchOpen) === null || _a === void 0 ? void 0 : _a.call(tree)) !== null && _b !== void 0 ? _b : false) && !tree.getState().dnd;
      },
      handler: (e, tree) => {
        tree.focusPreviousItem();
        tree.updateDomFocus();
      }
    },
    expandOrDown: {
      hotkey: "ArrowRight",
      canRepeat: true,
      handler: (e, tree) => {
        const item = tree.getFocusedItem();
        if (item.isExpanded() || !item.isFolder()) {
          tree.focusNextItem();
          tree.updateDomFocus();
        } else {
          item.expand();
        }
      }
    },
    collapseOrUp: {
      hotkey: "ArrowLeft",
      canRepeat: true,
      handler: (e, tree) => {
        var _a;
        const item = tree.getFocusedItem();
        if ((!item.isExpanded() || !item.isFolder()) && item.getItemMeta().level !== 0) {
          (_a = item.getParent()) === null || _a === void 0 ? void 0 : _a.setFocused();
          tree.updateDomFocus();
        } else {
          item.collapse();
        }
      }
    },
    focusFirstItem: {
      hotkey: "Home",
      handler: (e, tree) => {
        var _a;
        (_a = tree.getItems()[0]) === null || _a === void 0 ? void 0 : _a.setFocused();
        tree.updateDomFocus();
      }
    },
    focusLastItem: {
      hotkey: "End",
      handler: (e, tree) => {
        var _a;
        (_a = tree.getItems()[tree.getItems().length - 1]) === null || _a === void 0 ? void 0 : _a.setFocused();
        tree.updateDomFocus();
      }
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/core/build-static-instance.js
var buildStaticInstance = (features, instanceType, buildOpts) => {
  const instance = {};
  const finalize = () => {
    const opts = buildOpts(instance);
    featureLoop: for (let i = 0; i < features.length; i++) {
      const definition = features[i][instanceType];
      if (!definition)
        continue featureLoop;
      methodLoop: for (const [key, method] of Object.entries(definition)) {
        if (!method)
          continue methodLoop;
        const prev = instance[key];
        instance[key] = (...args) => {
          return method(Object.assign(Object.assign({}, opts), { prev }), ...args);
        };
      }
    }
  };
  return [instance, finalize];
};

// node_modules/@headless-tree/core/lib/esm/core/create-tree.js
var verifyFeatures = (features) => {
  var _a;
  const loadedFeatures = features === null || features === void 0 ? void 0 : features.map((feature) => feature.key);
  for (const feature of features !== null && features !== void 0 ? features : []) {
    const missingDependency = (_a = feature.deps) === null || _a === void 0 ? void 0 : _a.find((dep) => !(loadedFeatures === null || loadedFeatures === void 0 ? void 0 : loadedFeatures.includes(dep)));
    if (missingDependency) {
      throw throwError(`${feature.key} needs ${missingDependency}`);
    }
  }
};
var exhaustiveSort = (arr, compareFn) => {
  const n = arr.length;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (compareFn(arr[j], arr[i]) < 0) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
  }
  return arr;
};
var compareFeatures = (originalOrder) => (feature1, feature2) => {
  var _a, _b;
  if (feature2.key && ((_a = feature1.overwrites) === null || _a === void 0 ? void 0 : _a.includes(feature2.key))) {
    return 1;
  }
  if (feature1.key && ((_b = feature2.overwrites) === null || _b === void 0 ? void 0 : _b.includes(feature1.key))) {
    return -1;
  }
  return originalOrder.indexOf(feature1) - originalOrder.indexOf(feature2);
};
var sortFeatures = (features = []) => exhaustiveSort(features, compareFeatures(features));
var createTree = (initialConfig) => {
  var _a, _b, _c, _d;
  const buildInstance = (_a = initialConfig.instanceBuilder) !== null && _a !== void 0 ? _a : buildStaticInstance;
  const additionalFeatures = [
    treeFeature,
    ...sortFeatures(initialConfig.features)
  ];
  verifyFeatures(additionalFeatures);
  const features = [...additionalFeatures];
  const [treeInstance, finalizeTree] = buildInstance(features, "treeInstance", (tree) => ({ tree }));
  let state = additionalFeatures.reduce((acc, feature) => {
    var _a2, _b2;
    return (_b2 = (_a2 = feature.getInitialState) === null || _a2 === void 0 ? void 0 : _a2.call(feature, acc, treeInstance)) !== null && _b2 !== void 0 ? _b2 : acc;
  }, (_c = (_b = initialConfig.initialState) !== null && _b !== void 0 ? _b : initialConfig.state) !== null && _c !== void 0 ? _c : {});
  let config = additionalFeatures.reduce((acc, feature) => {
    var _a2, _b2;
    return (_b2 = (_a2 = feature.getDefaultConfig) === null || _a2 === void 0 ? void 0 : _a2.call(feature, acc, treeInstance)) !== null && _b2 !== void 0 ? _b2 : acc;
  }, initialConfig);
  const stateHandlerNames = additionalFeatures.reduce((acc, feature) => Object.assign(Object.assign({}, acc), feature.stateHandlerNames), {});
  let treeElement;
  const treeDataRef = { current: {} };
  const itemInstancesMap = {};
  let itemInstances = [];
  const itemElementsMap = {};
  const itemDataRefs = {};
  let itemMetaMap = {};
  const hotkeyPresets = {};
  const rebuildItemMeta = () => {
    itemInstances = [];
    itemMetaMap = {};
    const [rootInstance, finalizeRootInstance] = buildInstance(features, "itemInstance", (item) => ({ item, tree: treeInstance, itemId: config.rootItemId }));
    finalizeRootInstance();
    itemInstancesMap[config.rootItemId] = rootInstance;
    itemMetaMap[config.rootItemId] = {
      itemId: config.rootItemId,
      index: -1,
      parentId: null,
      level: -1,
      posInSet: 0,
      setSize: 1
    };
    for (const item of treeInstance.getItemsMeta()) {
      itemMetaMap[item.itemId] = item;
      if (!itemInstancesMap[item.itemId]) {
        const [instance, finalizeInstance] = buildInstance(features, "itemInstance", (instance2) => ({
          item: instance2,
          tree: treeInstance,
          itemId: item.itemId
        }));
        finalizeInstance();
        itemInstancesMap[item.itemId] = instance;
        itemInstances.push(instance);
      } else {
        itemInstances.push(itemInstancesMap[item.itemId]);
      }
    }
  };
  const eachFeature = (fn) => {
    for (const feature of additionalFeatures) {
      fn(feature);
    }
  };
  const mainFeature = {
    key: "main",
    treeInstance: {
      getState: () => state,
      setState: ({}, updater) => {
        var _a2;
        (_a2 = config.setState) === null || _a2 === void 0 ? void 0 : _a2.call(config, state);
      },
      applySubStateUpdate: ({}, stateName, updater) => {
        state[stateName] = typeof updater === "function" ? updater(state[stateName]) : updater;
        const externalStateSetter = config[stateHandlerNames[stateName]];
        externalStateSetter === null || externalStateSetter === void 0 ? void 0 : externalStateSetter(state[stateName]);
      },
      buildItemInstance: ({}, itemId) => {
        const [instance, finalizeInstance] = buildInstance(features, "itemInstance", (instance2) => ({
          item: instance2,
          tree: treeInstance,
          itemId
        }));
        finalizeInstance();
        return instance;
      },
      // TODO rebuildSubTree: (itemId: string) => void;
      rebuildTree: () => {
        var _a2;
        rebuildItemMeta();
        (_a2 = config.setState) === null || _a2 === void 0 ? void 0 : _a2.call(config, state);
      },
      getConfig: () => config,
      setConfig: (_, updater) => {
        var _a2, _b2, _c2;
        const newConfig = typeof updater === "function" ? updater(config) : updater;
        const hasChangedExpandedItems = ((_a2 = newConfig.state) === null || _a2 === void 0 ? void 0 : _a2.expandedItems) && ((_b2 = newConfig.state) === null || _b2 === void 0 ? void 0 : _b2.expandedItems) !== state.expandedItems;
        config = newConfig;
        if (newConfig.state) {
          state = Object.assign(Object.assign({}, state), newConfig.state);
        }
        if (hasChangedExpandedItems) {
          rebuildItemMeta();
          (_c2 = config.setState) === null || _c2 === void 0 ? void 0 : _c2.call(config, state);
        }
      },
      getItemInstance: ({}, itemId) => itemInstancesMap[itemId],
      getItems: () => itemInstances,
      registerElement: ({}, element) => {
        if (treeElement === element) {
          return;
        }
        if (treeElement && !element) {
          eachFeature((feature) => {
            var _a2;
            return (_a2 = feature.onTreeUnmount) === null || _a2 === void 0 ? void 0 : _a2.call(feature, treeInstance, treeElement);
          });
        } else if (!treeElement && element) {
          eachFeature((feature) => {
            var _a2;
            return (_a2 = feature.onTreeMount) === null || _a2 === void 0 ? void 0 : _a2.call(feature, treeInstance, element);
          });
        }
        treeElement = element;
      },
      getElement: () => treeElement,
      getDataRef: () => treeDataRef,
      getHotkeyPresets: () => hotkeyPresets
    },
    itemInstance: {
      registerElement: ({ itemId, item }, element) => {
        if (itemElementsMap[itemId] === element) {
          return;
        }
        const oldElement = itemElementsMap[itemId];
        if (oldElement && !element) {
          eachFeature((feature) => {
            var _a2;
            return (_a2 = feature.onItemUnmount) === null || _a2 === void 0 ? void 0 : _a2.call(feature, item, oldElement, treeInstance);
          });
        } else if (!oldElement && element) {
          eachFeature((feature) => {
            var _a2;
            return (_a2 = feature.onItemMount) === null || _a2 === void 0 ? void 0 : _a2.call(feature, item, element, treeInstance);
          });
        }
        itemElementsMap[itemId] = element;
      },
      getElement: ({ itemId }) => itemElementsMap[itemId],
      // eslint-disable-next-line no-return-assign
      getDataRef: ({ itemId }) => {
        var _a2;
        return (_a2 = itemDataRefs[itemId]) !== null && _a2 !== void 0 ? _a2 : itemDataRefs[itemId] = { current: {} };
      },
      getItemMeta: ({ itemId }) => itemMetaMap[itemId]
    }
  };
  features.unshift(mainFeature);
  for (const feature of features) {
    Object.assign(hotkeyPresets, (_d = feature.hotkeys) !== null && _d !== void 0 ? _d : {});
  }
  finalizeTree();
  return treeInstance;
};

// node_modules/@headless-tree/core/lib/esm/features/drag-and-drop/types.js
var DragTargetPosition;
(function(DragTargetPosition2) {
  DragTargetPosition2["Top"] = "top";
  DragTargetPosition2["Bottom"] = "bottom";
  DragTargetPosition2["Item"] = "item";
})(DragTargetPosition || (DragTargetPosition = {}));

// node_modules/@headless-tree/core/lib/esm/features/keyboard-drag-and-drop/types.js
var AssistiveDndState;
(function(AssistiveDndState2) {
  AssistiveDndState2[AssistiveDndState2["None"] = 0] = "None";
  AssistiveDndState2[AssistiveDndState2["Started"] = 1] = "Started";
  AssistiveDndState2[AssistiveDndState2["Dragging"] = 2] = "Dragging";
  AssistiveDndState2[AssistiveDndState2["Completed"] = 3] = "Completed";
  AssistiveDndState2[AssistiveDndState2["Aborted"] = 4] = "Aborted";
})(AssistiveDndState || (AssistiveDndState = {}));

// node_modules/@headless-tree/core/lib/esm/features/checkboxes/types.js
var CheckedState;
(function(CheckedState2) {
  CheckedState2["Checked"] = "checked";
  CheckedState2["Unchecked"] = "unchecked";
  CheckedState2["Indeterminate"] = "indeterminate";
})(CheckedState || (CheckedState = {}));

// node_modules/@headless-tree/core/lib/esm/features/selection/feature.js
var selectionFeature = {
  key: "selection",
  getInitialState: (initialState) => Object.assign({ selectedItems: [] }, initialState),
  getDefaultConfig: (defaultConfig, tree) => Object.assign({ setSelectedItems: makeStateUpdater("selectedItems", tree) }, defaultConfig),
  stateHandlerNames: {
    selectedItems: "setSelectedItems"
  },
  treeInstance: {
    setSelectedItems: ({ tree }, selectedItems) => {
      tree.applySubStateUpdate("selectedItems", selectedItems);
    },
    getSelectedItems: ({ tree }) => {
      return tree.getState().selectedItems.map(tree.getItemInstance);
    }
  },
  itemInstance: {
    select: ({ tree, itemId }) => {
      const { selectedItems } = tree.getState();
      tree.setSelectedItems(selectedItems.includes(itemId) ? selectedItems : [...selectedItems, itemId]);
    },
    deselect: ({ tree, itemId }) => {
      const { selectedItems } = tree.getState();
      tree.setSelectedItems(selectedItems.filter((id) => id !== itemId));
    },
    isSelected: ({ tree, itemId }) => {
      const { selectedItems } = tree.getState();
      return selectedItems.includes(itemId);
    },
    selectUpTo: ({ tree, item }, ctrl) => {
      const indexA = item.getItemMeta().index;
      const indexB = tree.getFocusedItem().getItemMeta().index;
      const [a, b] = indexA < indexB ? [indexA, indexB] : [indexB, indexA];
      const newSelectedItems = tree.getItems().slice(a, b + 1).map((treeItem) => treeItem.getItemMeta().itemId);
      if (!ctrl) {
        tree.setSelectedItems(newSelectedItems);
        return;
      }
      const { selectedItems } = tree.getState();
      const uniqueSelectedItems = [
        .../* @__PURE__ */ new Set([...selectedItems, ...newSelectedItems])
      ];
      tree.setSelectedItems(uniqueSelectedItems);
    },
    toggleSelect: ({ item }) => {
      if (item.isSelected()) {
        item.deselect();
      } else {
        item.select();
      }
    },
    getProps: ({ tree, item, prev }) => Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { "aria-selected": item.isSelected() ? "true" : "false", onClick: (e) => {
      var _a, _b;
      if (e.shiftKey) {
        item.selectUpTo(e.ctrlKey || e.metaKey);
      } else if (e.ctrlKey || e.metaKey) {
        item.toggleSelect();
      } else {
        tree.setSelectedItems([item.getItemMeta().itemId]);
      }
      (_b = (_a = prev === null || prev === void 0 ? void 0 : prev()) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    } })
  },
  hotkeys: {
    // setSelectedItem: {
    //   hotkey: "space",
    //   handler: (e, tree) => {
    //     tree.setSelectedItems([tree.getFocusedItem().getId()]);
    //   },
    // },
    toggleSelectedItem: {
      hotkey: "Control+Space",
      preventDefault: true,
      handler: (_, tree) => {
        tree.getFocusedItem().toggleSelect();
      }
    },
    selectUpwards: {
      hotkey: "Shift+ArrowUp",
      handler: (e, tree) => {
        const focused = tree.getFocusedItem();
        const above = focused.getItemAbove();
        if (!above)
          return;
        if (focused.isSelected() && above.isSelected()) {
          focused.deselect();
        } else {
          above.select();
        }
        above.setFocused();
        tree.updateDomFocus();
      }
    },
    selectDownwards: {
      hotkey: "Shift+ArrowDown",
      handler: (e, tree) => {
        const focused = tree.getFocusedItem();
        const below = focused.getItemBelow();
        if (!below)
          return;
        if (focused.isSelected() && below.isSelected()) {
          focused.deselect();
        } else {
          below.select();
        }
        below.setFocused();
        tree.updateDomFocus();
      }
    },
    selectAll: {
      hotkey: "Control+KeyA",
      preventDefault: true,
      handler: (e, tree) => {
        tree.setSelectedItems(tree.getItems().map((item) => item.getId()));
      }
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/features/checkboxes/feature.js
var getAllLoadedDescendants = (tree, itemId) => {
  if (!tree.getConfig().isItemFolder(tree.buildItemInstance(itemId))) {
    return [itemId];
  }
  return tree.retrieveChildrenIds(itemId).map((child) => getAllLoadedDescendants(tree, child)).flat();
};
var checkboxesFeature = {
  key: "checkboxes",
  overwrites: ["selection"],
  getInitialState: (initialState) => Object.assign({ checkedItems: [] }, initialState),
  getDefaultConfig: (defaultConfig, tree) => {
    var _a;
    const hasAsyncLoader = (_a = defaultConfig.features) === null || _a === void 0 ? void 0 : _a.some((f) => f.key === "async-data-loader");
    if (hasAsyncLoader && !defaultConfig.canCheckFolders) {
      throwError(`!canCheckFolders not supported with async trees`);
    }
    return Object.assign({ setCheckedItems: makeStateUpdater("checkedItems", tree), canCheckFolders: hasAsyncLoader !== null && hasAsyncLoader !== void 0 ? hasAsyncLoader : false }, defaultConfig);
  },
  stateHandlerNames: {
    checkedItems: "setCheckedItems"
  },
  treeInstance: {
    setCheckedItems: ({ tree }, checkedItems) => {
      tree.applySubStateUpdate("checkedItems", checkedItems);
    }
  },
  itemInstance: {
    getCheckboxProps: ({ item }) => {
      const checkedState = item.getCheckedState();
      return {
        onChange: item.toggleCheckedState,
        checked: checkedState === CheckedState.Checked,
        ref: (r) => {
          if (r) {
            r.indeterminate = checkedState === CheckedState.Indeterminate;
          }
        }
      };
    },
    toggleCheckedState: ({ item }) => {
      if (item.getCheckedState() === CheckedState.Checked) {
        item.setUnchecked();
      } else {
        item.setChecked();
      }
    },
    getCheckedState: ({ item, tree, itemId }) => {
      const { checkedItems } = tree.getState();
      if (checkedItems.includes(itemId)) {
        return CheckedState.Checked;
      }
      if (item.isFolder() && !tree.getConfig().canCheckFolders) {
        const descendants = getAllLoadedDescendants(tree, itemId);
        if (descendants.every((d) => checkedItems.includes(d))) {
          return CheckedState.Checked;
        }
        if (descendants.some((d) => checkedItems.includes(d))) {
          return CheckedState.Indeterminate;
        }
      }
      return CheckedState.Unchecked;
    },
    setChecked: ({ item, tree, itemId }) => {
      if (!item.isFolder() || tree.getConfig().canCheckFolders) {
        tree.applySubStateUpdate("checkedItems", (items) => [...items, itemId]);
      } else {
        tree.applySubStateUpdate("checkedItems", (items) => [
          ...items,
          ...getAllLoadedDescendants(tree, itemId)
        ]);
      }
    },
    setUnchecked: ({ item, tree, itemId }) => {
      if (!item.isFolder() || tree.getConfig().canCheckFolders) {
        tree.applySubStateUpdate("checkedItems", (items) => items.filter((id) => id !== itemId));
      } else {
        const descendants = getAllLoadedDescendants(tree, itemId);
        tree.applySubStateUpdate("checkedItems", (items) => items.filter((id) => !descendants.includes(id)));
      }
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/features/hotkeys-core/feature.js
var specialKeys = {
  // TODO:breaking deprecate auto-lowercase
  letter: /^Key[A-Z]$/,
  letterornumber: /^(Key[A-Z]|Digit[0-9])$/,
  plus: /^(NumpadAdd|Plus)$/,
  minus: /^(NumpadSubtract|Minus)$/,
  control: /^(ControlLeft|ControlRight)$/,
  shift: /^(ShiftLeft|ShiftRight)$/
};
var testHotkeyMatch = (pressedKeys, tree, hotkey) => {
  const supposedKeys = hotkey.hotkey.toLowerCase().split("+");
  const doKeysMatch = supposedKeys.every((key) => {
    if (key in specialKeys) {
      return [...pressedKeys].some((pressedKey) => specialKeys[key].test(pressedKey));
    }
    const pressedKeysLowerCase = [...pressedKeys].map((k) => k.toLowerCase());
    if (pressedKeysLowerCase.includes(key.toLowerCase())) {
      return true;
    }
    if (pressedKeysLowerCase.includes(`key${key.toLowerCase()}`)) {
      return true;
    }
    return false;
  });
  const isEnabled = !hotkey.isEnabled || hotkey.isEnabled(tree);
  const equalCounts = pressedKeys.size === supposedKeys.length;
  return doKeysMatch && isEnabled && equalCounts;
};
var findHotkeyMatch = (pressedKeys, tree, config1, config2) => {
  var _a;
  return (_a = Object.entries(Object.assign(Object.assign({}, config1), config2)).find(([, hotkey]) => testHotkeyMatch(pressedKeys, tree, hotkey))) === null || _a === void 0 ? void 0 : _a[0];
};
var hotkeysCoreFeature = {
  key: "hotkeys-core",
  onTreeMount: (tree, element) => {
    const data = tree.getDataRef();
    const keydown = (e) => {
      var _a;
      var _b;
      const { ignoreHotkeysOnInputs, onTreeHotkey, hotkeys } = tree.getConfig();
      if (e.target instanceof HTMLInputElement && ignoreHotkeysOnInputs) {
        return;
      }
      (_a = (_b = data.current).pressedKeys) !== null && _a !== void 0 ? _a : _b.pressedKeys = /* @__PURE__ */ new Set();
      const newMatch = !data.current.pressedKeys.has(e.code);
      data.current.pressedKeys.add(e.code);
      const hotkeyName = findHotkeyMatch(data.current.pressedKeys, tree, tree.getHotkeyPresets(), hotkeys);
      if (e.target instanceof HTMLInputElement) {
        data.current.pressedKeys.delete(e.code);
      }
      if (!hotkeyName)
        return;
      const hotkeyConfig = Object.assign(Object.assign({}, tree.getHotkeyPresets()[hotkeyName]), hotkeys === null || hotkeys === void 0 ? void 0 : hotkeys[hotkeyName]);
      if (!hotkeyConfig)
        return;
      if (!hotkeyConfig.allowWhenInputFocused && e.target instanceof HTMLInputElement)
        return;
      if (!hotkeyConfig.canRepeat && !newMatch)
        return;
      if (hotkeyConfig.preventDefault)
        e.preventDefault();
      hotkeyConfig.handler(e, tree);
      onTreeHotkey === null || onTreeHotkey === void 0 ? void 0 : onTreeHotkey(hotkeyName, e);
    };
    const keyup = (e) => {
      var _a;
      var _b;
      (_a = (_b = data.current).pressedKeys) !== null && _a !== void 0 ? _a : _b.pressedKeys = /* @__PURE__ */ new Set();
      data.current.pressedKeys.delete(e.code);
    };
    const reset = () => {
      data.current.pressedKeys = /* @__PURE__ */ new Set();
    };
    element.addEventListener("keydown", keydown);
    document.addEventListener("keyup", keyup);
    window.addEventListener("focus", reset);
    data.current.keydownHandler = keydown;
    data.current.keyupHandler = keyup;
    data.current.resetHandler = reset;
  },
  onTreeUnmount: (tree, element) => {
    const data = tree.getDataRef();
    if (data.current.keyupHandler) {
      document.removeEventListener("keyup", data.current.keyupHandler);
      delete data.current.keyupHandler;
    }
    if (data.current.keydownHandler) {
      element.removeEventListener("keydown", data.current.keydownHandler);
      delete data.current.keydownHandler;
    }
    if (data.current.resetHandler) {
      window.removeEventListener("focus", data.current.resetHandler);
      delete data.current.resetHandler;
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/features/async-data-loader/feature.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getDataRef = (tree) => {
  var _a, _b;
  var _c, _d;
  const dataRef = tree.getDataRef();
  (_a = (_c = dataRef.current).itemData) !== null && _a !== void 0 ? _a : _c.itemData = {};
  (_b = (_d = dataRef.current).childrenIds) !== null && _b !== void 0 ? _b : _d.childrenIds = {};
  return dataRef;
};
var loadItemData = (tree, itemId) => __awaiter2(void 0, void 0, void 0, function* () {
  var _a;
  const config = tree.getConfig();
  const dataRef = getDataRef(tree);
  const item = yield config.dataLoader.getItem(itemId);
  dataRef.current.itemData[itemId] = item;
  (_a = config.onLoadedItem) === null || _a === void 0 ? void 0 : _a.call(config, itemId, item);
  tree.applySubStateUpdate("loadingItemData", (loadingItemData) => loadingItemData.filter((id) => id !== itemId));
  return item;
});
var loadChildrenIds = (tree, itemId) => __awaiter2(void 0, void 0, void 0, function* () {
  var _a, _b;
  const config = tree.getConfig();
  const dataRef = getDataRef(tree);
  let childrenIds;
  if ("getChildrenWithData" in config.dataLoader) {
    const children = yield config.dataLoader.getChildrenWithData(itemId);
    childrenIds = children.map((c) => c.id);
    dataRef.current.childrenIds[itemId] = childrenIds;
    children.forEach(({ id, data }) => {
      var _a2;
      dataRef.current.itemData[id] = data;
      (_a2 = config.onLoadedItem) === null || _a2 === void 0 ? void 0 : _a2.call(config, id, data);
    });
    (_a = config.onLoadedChildren) === null || _a === void 0 ? void 0 : _a.call(config, itemId, childrenIds);
    tree.rebuildTree();
    tree.applySubStateUpdate("loadingItemData", (loadingItemData) => loadingItemData.filter((id) => !childrenIds.includes(id)));
  } else {
    childrenIds = yield config.dataLoader.getChildren(itemId);
    dataRef.current.childrenIds[itemId] = childrenIds;
    (_b = config.onLoadedChildren) === null || _b === void 0 ? void 0 : _b.call(config, itemId, childrenIds);
    tree.rebuildTree();
  }
  tree.applySubStateUpdate("loadingItemChildrens", (loadingItemChildrens) => loadingItemChildrens.filter((id) => id !== itemId));
  return childrenIds;
});
var asyncDataLoaderFeature = {
  key: "async-data-loader",
  getInitialState: (initialState) => Object.assign({ loadingItemData: [], loadingItemChildrens: [] }, initialState),
  getDefaultConfig: (defaultConfig, tree) => Object.assign({ setLoadingItemData: makeStateUpdater("loadingItemData", tree), setLoadingItemChildrens: makeStateUpdater("loadingItemChildrens", tree) }, defaultConfig),
  stateHandlerNames: {
    loadingItemData: "setLoadingItemData",
    loadingItemChildrens: "setLoadingItemChildrens"
  },
  treeInstance: {
    waitForItemDataLoaded: ({ tree }, itemId) => tree.loadItemData(itemId),
    waitForItemChildrenLoaded: ({ tree }, itemId) => tree.loadChildrenIds(itemId),
    loadItemData: (_a, itemId_1) => __awaiter2(void 0, [_a, itemId_1], void 0, function* ({ tree }, itemId) {
      var _b;
      return (_b = getDataRef(tree).current.itemData[itemId]) !== null && _b !== void 0 ? _b : yield loadItemData(tree, itemId);
    }),
    loadChildrenIds: (_a, itemId_1) => __awaiter2(void 0, [_a, itemId_1], void 0, function* ({ tree }, itemId) {
      var _b;
      return (_b = getDataRef(tree).current.childrenIds[itemId]) !== null && _b !== void 0 ? _b : yield loadChildrenIds(tree, itemId);
    }),
    retrieveItemData: ({ tree }, itemId, skipFetch = false) => {
      var _a, _b;
      const config = tree.getConfig();
      const dataRef = getDataRef(tree);
      if (dataRef.current.itemData[itemId]) {
        return dataRef.current.itemData[itemId];
      }
      if (!tree.getState().loadingItemData.includes(itemId) && !skipFetch) {
        tree.applySubStateUpdate("loadingItemData", (loadingItemData) => [
          ...loadingItemData,
          itemId
        ]);
        loadItemData(tree, itemId);
      }
      return (_b = (_a = config.createLoadingItemData) === null || _a === void 0 ? void 0 : _a.call(config)) !== null && _b !== void 0 ? _b : null;
    },
    retrieveChildrenIds: ({ tree }, itemId, skipFetch = false) => {
      const dataRef = getDataRef(tree);
      if (dataRef.current.childrenIds[itemId]) {
        return dataRef.current.childrenIds[itemId];
      }
      if (tree.getState().loadingItemChildrens.includes(itemId) || skipFetch) {
        return [];
      }
      tree.applySubStateUpdate("loadingItemChildrens", (loadingItemChildrens) => [...loadingItemChildrens, itemId]);
      loadChildrenIds(tree, itemId);
      return [];
    }
  },
  itemInstance: {
    isLoading: ({ tree, item }) => tree.getState().loadingItemData.includes(item.getItemMeta().itemId) || tree.getState().loadingItemChildrens.includes(item.getItemMeta().itemId),
    invalidateItemData: (_a, optimistic_1) => __awaiter2(void 0, [_a, optimistic_1], void 0, function* ({ tree, itemId }, optimistic) {
      var _b;
      if (!optimistic) {
        (_b = getDataRef(tree).current.itemData) === null || _b === void 0 ? true : delete _b[itemId];
        tree.applySubStateUpdate("loadingItemData", (loadingItemData) => [
          ...loadingItemData,
          itemId
        ]);
      }
      yield loadItemData(tree, itemId);
    }),
    invalidateChildrenIds: (_a, optimistic_1) => __awaiter2(void 0, [_a, optimistic_1], void 0, function* ({ tree, itemId }, optimistic) {
      var _b;
      if (!optimistic) {
        (_b = getDataRef(tree).current.childrenIds) === null || _b === void 0 ? true : delete _b[itemId];
        tree.applySubStateUpdate("loadingItemChildrens", (loadingItemChildrens) => [...loadingItemChildrens, itemId]);
      }
      yield loadChildrenIds(tree, itemId);
    }),
    updateCachedChildrenIds: ({ tree, itemId }, childrenIds) => {
      const dataRef = tree.getDataRef();
      dataRef.current.childrenIds[itemId] = childrenIds;
      tree.rebuildTree();
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/features/sync-data-loader/feature.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var promiseErrorMessage = "sync dataLoader returned promise";
var unpromise = (data) => {
  if (!data || typeof data === "object" && "then" in data) {
    throw throwError(promiseErrorMessage);
  }
  return data;
};
var syncDataLoaderFeature = {
  key: "sync-data-loader",
  getInitialState: (initialState) => Object.assign({ loadingItemData: [], loadingItemChildrens: [] }, initialState),
  getDefaultConfig: (defaultConfig, tree) => Object.assign({ setLoadingItemData: makeStateUpdater("loadingItemData", tree), setLoadingItemChildrens: makeStateUpdater("loadingItemChildrens", tree) }, defaultConfig),
  stateHandlerNames: {
    loadingItemData: "setLoadingItemData",
    loadingItemChildrens: "setLoadingItemChildrens"
  },
  treeInstance: {
    waitForItemDataLoaded: () => __awaiter3(void 0, void 0, void 0, function* () {
    }),
    waitForItemChildrenLoaded: () => __awaiter3(void 0, void 0, void 0, function* () {
    }),
    retrieveItemData: ({ tree }, itemId) => {
      return unpromise(tree.getConfig().dataLoader.getItem(itemId));
    },
    retrieveChildrenIds: ({ tree }, itemId) => {
      const { dataLoader } = tree.getConfig();
      if ("getChildren" in dataLoader) {
        return unpromise(dataLoader.getChildren(itemId));
      }
      return unpromise(dataLoader.getChildrenWithData(itemId)).map((c) => c.data);
    },
    loadItemData: ({ tree }, itemId) => tree.retrieveItemData(itemId),
    loadChildrenIds: ({ tree }, itemId) => tree.retrieveChildrenIds(itemId)
  },
  itemInstance: {
    isLoading: () => false
  }
};

// node_modules/@headless-tree/core/lib/esm/features/drag-and-drop/utils.js
var ItemDropCategory;
(function(ItemDropCategory2) {
  ItemDropCategory2[ItemDropCategory2["Item"] = 0] = "Item";
  ItemDropCategory2[ItemDropCategory2["ExpandedFolder"] = 1] = "ExpandedFolder";
  ItemDropCategory2[ItemDropCategory2["LastInGroup"] = 2] = "LastInGroup";
})(ItemDropCategory || (ItemDropCategory = {}));
var PlacementType;
(function(PlacementType2) {
  PlacementType2[PlacementType2["ReorderAbove"] = 0] = "ReorderAbove";
  PlacementType2[PlacementType2["ReorderBelow"] = 1] = "ReorderBelow";
  PlacementType2[PlacementType2["MakeChild"] = 2] = "MakeChild";
  PlacementType2[PlacementType2["Reparent"] = 3] = "Reparent";
})(PlacementType || (PlacementType = {}));
var isOrderedDragTarget = (dragTarget) => "childIndex" in dragTarget;
var canDrop = (dataTransfer, target, tree) => {
  var _a, _b, _c;
  const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
  const config = tree.getConfig();
  if (draggedItems && !((_c = (_b = config.canDrop) === null || _b === void 0 ? void 0 : _b.call(config, draggedItems, target)) !== null && _c !== void 0 ? _c : true)) {
    return false;
  }
  if (draggedItems && draggedItems.some((draggedItem) => target.item.getId() === draggedItem.getId() || target.item.isDescendentOf(draggedItem.getId()))) {
    return false;
  }
  if (!draggedItems && dataTransfer && config.canDropForeignDragObject && !config.canDropForeignDragObject(dataTransfer, target)) {
    return false;
  }
  return true;
};
var getItemDropCategory = (item) => {
  if (item.isExpanded()) {
    return ItemDropCategory.ExpandedFolder;
  }
  const parent = item.getParent();
  if (parent && item.getIndexInParent() === item.getItemMeta().setSize - 1) {
    return ItemDropCategory.LastInGroup;
  }
  return ItemDropCategory.Item;
};
var getInsertionIndex = (children, childIndex, draggedItems) => {
  var _a;
  const numberOfDragItemsBeforeTarget = (_a = children.slice(0, childIndex).reduce((counter, child) => child && (draggedItems === null || draggedItems === void 0 ? void 0 : draggedItems.some((i) => i.getId() === child.getId())) ? ++counter : counter, 0)) !== null && _a !== void 0 ? _a : 0;
  return childIndex - numberOfDragItemsBeforeTarget;
};
var getTargetPlacement = (e, item, tree, canMakeChild) => {
  var _a, _b, _c, _d, _e;
  const config = tree.getConfig();
  if (!config.canReorder) {
    return canMakeChild ? { type: PlacementType.MakeChild } : { type: PlacementType.ReorderBelow };
  }
  const bb = (_a = item.getElement()) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
  const topPercent = bb ? (e.clientY - bb.top) / bb.height : 0.5;
  const leftPixels = bb ? e.clientX - bb.left : 0;
  const targetDropCategory = getItemDropCategory(item);
  const reorderAreaPercentage = !canMakeChild ? 0.5 : (_b = config.reorderAreaPercentage) !== null && _b !== void 0 ? _b : 0.3;
  const indent = (_c = config.indent) !== null && _c !== void 0 ? _c : 20;
  const makeChildType = canMakeChild ? PlacementType.MakeChild : PlacementType.ReorderBelow;
  if (targetDropCategory === ItemDropCategory.ExpandedFolder) {
    if (topPercent < reorderAreaPercentage) {
      return { type: PlacementType.ReorderAbove };
    }
    return { type: makeChildType };
  }
  if (targetDropCategory === ItemDropCategory.LastInGroup) {
    if (leftPixels < item.getItemMeta().level * indent) {
      if (topPercent < 0.5) {
        return { type: PlacementType.ReorderAbove };
      }
      const minLevel = (_e = (_d = item.getItemBelow()) === null || _d === void 0 ? void 0 : _d.getItemMeta().level) !== null && _e !== void 0 ? _e : 0;
      return {
        type: PlacementType.Reparent,
        reparentLevel: Math.max(minLevel, Math.floor(leftPixels / indent))
      };
    }
  }
  if (topPercent < reorderAreaPercentage) {
    return { type: PlacementType.ReorderAbove };
  }
  if (topPercent > 1 - reorderAreaPercentage) {
    return { type: PlacementType.ReorderBelow };
  }
  return { type: makeChildType };
};
var getDragCode = (e, item, tree) => {
  const placement = getTargetPlacement(e, item, tree, true);
  return [
    item.getId(),
    placement.type,
    placement.type === PlacementType.Reparent ? placement.reparentLevel : 0
  ].join("__");
};
var getNthParent = (item, n) => {
  if (n === item.getItemMeta().level) {
    return item;
  }
  return getNthParent(item.getParent(), n);
};
var getReparentTarget = (item, reparentLevel, draggedItems) => {
  const itemMeta = item.getItemMeta();
  const reparentedTarget = getNthParent(item, reparentLevel - 1);
  const targetItemAbove = getNthParent(item, reparentLevel);
  const targetIndex = targetItemAbove.getIndexInParent() + 1;
  return {
    item: reparentedTarget,
    childIndex: targetIndex,
    insertionIndex: getInsertionIndex(reparentedTarget.getChildren(), targetIndex, draggedItems),
    dragLineIndex: itemMeta.index + 1,
    dragLineLevel: reparentLevel
  };
};
var getDragTarget = (e, item, tree, canReorder = tree.getConfig().canReorder) => {
  var _a;
  const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
  const itemMeta = item.getItemMeta();
  const parent = item.getParent();
  const itemTarget = { item };
  const parentTarget = parent ? { item: parent } : null;
  const canBecomeSibling = parentTarget && canDrop(e.dataTransfer, parentTarget, tree);
  const canMakeChild = canDrop(e.dataTransfer, itemTarget, tree);
  const placement = getTargetPlacement(e, item, tree, canMakeChild);
  if (!canReorder && parent && canBecomeSibling && placement.type !== PlacementType.MakeChild) {
    return parentTarget;
  }
  if (!canReorder && parent && !canBecomeSibling) {
    return getDragTarget(e, parent, tree, false);
  }
  if (!parent) {
    return itemTarget;
  }
  if (placement.type === PlacementType.MakeChild) {
    return itemTarget;
  }
  if (!canBecomeSibling) {
    return getDragTarget(e, parent, tree, false);
  }
  if (placement.type === PlacementType.Reparent) {
    return getReparentTarget(item, placement.reparentLevel, draggedItems);
  }
  const maybeAddOneForBelow = placement.type === PlacementType.ReorderAbove ? 0 : 1;
  const childIndex = item.getIndexInParent() + maybeAddOneForBelow;
  return {
    item: parent,
    dragLineIndex: itemMeta.index + maybeAddOneForBelow,
    dragLineLevel: itemMeta.level,
    childIndex,
    // TODO performance could be improved by computing this only when dragcode changed
    insertionIndex: getInsertionIndex(parent.getChildren(), childIndex, draggedItems)
  };
};

// node_modules/@headless-tree/core/lib/esm/features/drag-and-drop/feature.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var dragAndDropFeature = {
  key: "drag-and-drop",
  deps: ["selection"],
  getDefaultConfig: (defaultConfig, tree) => Object.assign({ canDrop: (_, target) => target.item.isFolder(), canDropForeignDragObject: () => false, setDndState: makeStateUpdater("dnd", tree), canReorder: true }, defaultConfig),
  stateHandlerNames: {
    dnd: "setDndState"
  },
  treeInstance: {
    getDragTarget: ({ tree }) => {
      var _a, _b;
      return (_b = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.dragTarget) !== null && _b !== void 0 ? _b : null;
    },
    getDragLineData: ({ tree }) => {
      var _a, _b, _c, _d, _e, _f;
      const target = tree.getDragTarget();
      const indent = ((_a = target === null || target === void 0 ? void 0 : target.item.getItemMeta().level) !== null && _a !== void 0 ? _a : 0) + 1;
      const treeBb = (_b = tree.getElement()) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
      if (!target || !treeBb || !isOrderedDragTarget(target))
        return null;
      const leftOffset = target.dragLineLevel * ((_c = tree.getConfig().indent) !== null && _c !== void 0 ? _c : 1);
      const targetItem = tree.getItems()[target.dragLineIndex];
      if (!targetItem) {
        const bb2 = (_e = (_d = tree.getItems()[target.dragLineIndex - 1]) === null || _d === void 0 ? void 0 : _d.getElement()) === null || _e === void 0 ? void 0 : _e.getBoundingClientRect();
        if (bb2) {
          return {
            indent,
            top: bb2.bottom - treeBb.top,
            left: bb2.left + leftOffset - treeBb.left,
            width: bb2.width - leftOffset
          };
        }
      }
      const bb = (_f = targetItem.getElement()) === null || _f === void 0 ? void 0 : _f.getBoundingClientRect();
      if (bb) {
        return {
          indent,
          top: bb.top - treeBb.top,
          left: bb.left + leftOffset - treeBb.left,
          width: bb.width - leftOffset
        };
      }
      return null;
    },
    getDragLineStyle: ({ tree }, topOffset = -1, leftOffset = -8) => {
      const dragLine = tree.getDragLineData();
      return dragLine ? {
        position: "absolute",
        top: `${dragLine.top + topOffset}px`,
        left: `${dragLine.left + leftOffset}px`,
        width: `${dragLine.width - leftOffset}px`,
        pointerEvents: "none"
        // important to prevent capturing drag events
      } : { display: "none" };
    },
    getContainerProps: ({ prev, tree }, treeLabel) => {
      const prevProps = prev === null || prev === void 0 ? void 0 : prev(treeLabel);
      return Object.assign(Object.assign({}, prevProps), { onDragOver: (e) => {
        e.preventDefault();
      }, onDrop: (e) => __awaiter4(void 0, void 0, void 0, function* () {
        var _a, _b, _c;
        const dataRef = tree.getDataRef();
        const target = { item: tree.getRootItem() };
        if (!canDrop(e.dataTransfer, target, tree)) {
          return;
        }
        e.preventDefault();
        const config = tree.getConfig();
        const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
        dataRef.current.lastDragCode = void 0;
        tree.applySubStateUpdate("dnd", null);
        if (draggedItems) {
          yield (_b = config.onDrop) === null || _b === void 0 ? void 0 : _b.call(config, draggedItems, target);
        } else if (e.dataTransfer) {
          yield (_c = config.onDropForeignDragObject) === null || _c === void 0 ? void 0 : _c.call(config, e.dataTransfer, target);
        }
      }), style: Object.assign(Object.assign({}, prevProps === null || prevProps === void 0 ? void 0 : prevProps.style), { position: "relative" }) });
    }
  },
  itemInstance: {
    getProps: ({ tree, item, prev }) => Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { draggable: true, onDragEnter: (e) => e.preventDefault(), onDragStart: (e) => {
      var _a, _b, _c, _d;
      const selectedItems = tree.getSelectedItems();
      const items = selectedItems.includes(item) ? selectedItems : [item];
      const config = tree.getConfig();
      if (!selectedItems.includes(item)) {
        tree.setSelectedItems([item.getItemMeta().itemId]);
      }
      if (!((_b = (_a = config.canDrag) === null || _a === void 0 ? void 0 : _a.call(config, items)) !== null && _b !== void 0 ? _b : true)) {
        e.preventDefault();
        return;
      }
      if (config.setDragImage) {
        const { imgElement, xOffset, yOffset } = config.setDragImage(items);
        (_c = e.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(imgElement, xOffset !== null && xOffset !== void 0 ? xOffset : 0, yOffset !== null && yOffset !== void 0 ? yOffset : 0);
      }
      if (config.createForeignDragObject) {
        const { format, data } = config.createForeignDragObject(items);
        (_d = e.dataTransfer) === null || _d === void 0 ? void 0 : _d.setData(format, data);
      }
      tree.applySubStateUpdate("dnd", {
        draggedItems: items,
        draggingOverItem: tree.getFocusedItem()
      });
    }, onDragOver: (e) => {
      var _a, _b, _c;
      const dataRef = tree.getDataRef();
      const nextDragCode = getDragCode(e, item, tree);
      if (nextDragCode === dataRef.current.lastDragCode) {
        if (dataRef.current.lastAllowDrop) {
          e.preventDefault();
        }
        return;
      }
      dataRef.current.lastDragCode = nextDragCode;
      const target = getDragTarget(e, item, tree);
      if (!((_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems) && (!e.dataTransfer || !((_c = (_b = tree.getConfig()).canDropForeignDragObject) === null || _c === void 0 ? void 0 : _c.call(_b, e.dataTransfer, target)))) {
        dataRef.current.lastAllowDrop = false;
        return;
      }
      if (!canDrop(e.dataTransfer, target, tree)) {
        dataRef.current.lastAllowDrop = false;
        return;
      }
      tree.applySubStateUpdate("dnd", (state) => Object.assign(Object.assign({}, state), { dragTarget: target, draggingOverItem: item }));
      dataRef.current.lastAllowDrop = true;
      e.preventDefault();
    }, onDragLeave: () => {
      const dataRef = tree.getDataRef();
      dataRef.current.lastDragCode = "no-drag";
      tree.applySubStateUpdate("dnd", (state) => Object.assign(Object.assign({}, state), { draggingOverItem: void 0, dragTarget: void 0 }));
    }, onDragEnd: (e) => {
      var _a, _b, _c, _d;
      const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
      tree.applySubStateUpdate("dnd", null);
      if (((_b = e.dataTransfer) === null || _b === void 0 ? void 0 : _b.dropEffect) === "none" || !draggedItems) {
        return;
      }
      (_d = (_c = tree.getConfig()).onCompleteForeignDrop) === null || _d === void 0 ? void 0 : _d.call(_c, draggedItems);
    }, onDrop: (e) => __awaiter4(void 0, void 0, void 0, function* () {
      var _a, _b, _c;
      e.stopPropagation();
      const dataRef = tree.getDataRef();
      const target = getDragTarget(e, item, tree);
      if (!canDrop(e.dataTransfer, target, tree)) {
        return;
      }
      e.preventDefault();
      const config = tree.getConfig();
      const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
      dataRef.current.lastDragCode = void 0;
      tree.applySubStateUpdate("dnd", null);
      if (draggedItems) {
        yield (_b = config.onDrop) === null || _b === void 0 ? void 0 : _b.call(config, draggedItems, target);
      } else if (e.dataTransfer) {
        yield (_c = config.onDropForeignDragObject) === null || _c === void 0 ? void 0 : _c.call(config, e.dataTransfer, target);
      }
    }) }),
    isDragTarget: ({ tree, item }) => {
      const target = tree.getDragTarget();
      return target ? target.item.getId() === item.getId() : false;
    },
    isDragTargetAbove: ({ tree, item }) => {
      const target = tree.getDragTarget();
      if (!target || !isOrderedDragTarget(target) || target.item !== item.getParent())
        return false;
      return target.childIndex === item.getItemMeta().posInSet;
    },
    isDragTargetBelow: ({ tree, item }) => {
      const target = tree.getDragTarget();
      if (!target || !isOrderedDragTarget(target) || target.item !== item.getParent())
        return false;
      return target.childIndex - 1 === item.getItemMeta().posInSet;
    },
    isDraggingOver: ({ tree, item }) => {
      var _a, _b;
      return ((_b = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggingOverItem) === null || _b === void 0 ? void 0 : _b.getId()) === item.getId();
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/features/keyboard-drag-and-drop/feature.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getNextDragTarget = (tree, isUp, dragTarget) => {
  var _a, _b, _c, _d;
  const direction = isUp ? 0 : 1;
  const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;
  if (isOrderedDragTarget(dragTarget)) {
    const parent = dragTarget.item.getParent();
    const targetedItem = tree.getItems()[dragTarget.dragLineIndex - 1];
    const targetCategory = targetedItem ? getItemDropCategory(targetedItem) : ItemDropCategory.Item;
    const maxLevel = (_b = targetedItem === null || targetedItem === void 0 ? void 0 : targetedItem.getItemMeta().level) !== null && _b !== void 0 ? _b : 0;
    const minLevel = (_d = (_c = targetedItem === null || targetedItem === void 0 ? void 0 : targetedItem.getItemBelow()) === null || _c === void 0 ? void 0 : _c.getItemMeta().level) !== null && _d !== void 0 ? _d : 0;
    if (targetCategory === ItemDropCategory.LastInGroup) {
      if (isUp && dragTarget.dragLineLevel < maxLevel) {
        return getReparentTarget(targetedItem, dragTarget.dragLineLevel + 1, draggedItems);
      }
      if (!isUp && dragTarget.dragLineLevel > minLevel && parent) {
        return getReparentTarget(targetedItem, dragTarget.dragLineLevel - 1, draggedItems);
      }
    }
    const newIndex = dragTarget.dragLineIndex - 1 + direction;
    const item = tree.getItems()[newIndex];
    return item ? { item } : void 0;
  }
  const targetingExpandedFolder = getItemDropCategory(dragTarget.item) === ItemDropCategory.ExpandedFolder;
  if (targetingExpandedFolder && !isUp) {
    return {
      item: dragTarget.item,
      childIndex: 0,
      insertionIndex: getInsertionIndex(dragTarget.item.getChildren(), 0, draggedItems),
      dragLineIndex: dragTarget.item.getItemMeta().index + direction,
      dragLineLevel: dragTarget.item.getItemMeta().level + 1
    };
  }
  const childIndex = dragTarget.item.getIndexInParent() + direction;
  return {
    item: dragTarget.item.getParent(),
    childIndex,
    insertionIndex: getInsertionIndex(dragTarget.item.getParent().getChildren(), childIndex, draggedItems),
    dragLineIndex: dragTarget.item.getItemMeta().index + direction,
    dragLineLevel: dragTarget.item.getItemMeta().level
  };
};
var getNextValidDragTarget = (tree, isUp, previousTarget) => {
  var _a, _b;
  if (previousTarget === void 0) {
    previousTarget = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.dragTarget;
  }
  if (!previousTarget)
    return void 0;
  const nextTarget = getNextDragTarget(tree, isUp, previousTarget);
  const dataTransfer = (_b = tree.getDataRef().current.kDndDataTransfer) !== null && _b !== void 0 ? _b : null;
  if (!nextTarget)
    return void 0;
  if (canDrop(dataTransfer, nextTarget, tree)) {
    return nextTarget;
  }
  return getNextValidDragTarget(tree, isUp, nextTarget);
};
var updateScroll = (tree) => {
  const state = tree.getState().dnd;
  if (!(state === null || state === void 0 ? void 0 : state.dragTarget) || isOrderedDragTarget(state.dragTarget))
    return;
  state.dragTarget.item.scrollTo({ block: "nearest", inline: "nearest" });
};
var initiateDrag = (tree, draggedItems, dataTransfer) => {
  var _a, _b;
  const focusedItem = tree.getFocusedItem();
  const { canDrag } = tree.getConfig();
  if (draggedItems && canDrag && !canDrag(draggedItems)) {
    return;
  }
  if (draggedItems) {
    tree.applySubStateUpdate("dnd", { draggedItems });
    (_b = (_a = tree.getConfig()).onStartKeyboardDrag) === null || _b === void 0 ? void 0 : _b.call(_a, draggedItems);
  } else if (dataTransfer) {
    tree.getDataRef().current.kDndDataTransfer = dataTransfer;
  }
  const dragTarget = getNextValidDragTarget(tree, false, {
    item: focusedItem
  });
  if (!dragTarget)
    return;
  tree.applySubStateUpdate("dnd", {
    draggedItems,
    dragTarget
  });
  tree.applySubStateUpdate("assistiveDndState", AssistiveDndState.Started);
  updateScroll(tree);
};
var moveDragPosition = (tree, isUp) => {
  var _a;
  const dragTarget = getNextValidDragTarget(tree, isUp);
  if (!dragTarget)
    return;
  tree.applySubStateUpdate("dnd", {
    draggedItems: (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems,
    dragTarget
  });
  tree.applySubStateUpdate("assistiveDndState", AssistiveDndState.Dragging);
  if (!isOrderedDragTarget(dragTarget)) {
    dragTarget.item.setFocused();
  }
  updateScroll(tree);
};
var keyboardDragAndDropFeature = {
  key: "keyboard-drag-and-drop",
  deps: ["drag-and-drop"],
  getDefaultConfig: (defaultConfig, tree) => Object.assign({ setAssistiveDndState: makeStateUpdater("assistiveDndState", tree) }, defaultConfig),
  stateHandlerNames: {
    assistiveDndState: "setAssistiveDndState"
  },
  treeInstance: {
    startKeyboardDrag: ({ tree }, draggedItems) => {
      initiateDrag(tree, draggedItems, void 0);
    },
    startKeyboardDragOnForeignObject: ({ tree }, dataTransfer) => {
      initiateDrag(tree, void 0, dataTransfer);
    },
    stopKeyboardDrag: ({ tree }) => {
      tree.getDataRef().current.kDndDataTransfer = void 0;
      tree.applySubStateUpdate("dnd", null);
      tree.applySubStateUpdate("assistiveDndState", AssistiveDndState.None);
    }
  },
  hotkeys: {
    startDrag: {
      hotkey: "Control+Shift+KeyD",
      preventDefault: true,
      isEnabled: (tree) => !tree.getState().dnd,
      handler: (_, tree) => {
        tree.startKeyboardDrag(tree.getSelectedItems());
      }
    },
    dragUp: {
      hotkey: "ArrowUp",
      preventDefault: true,
      isEnabled: (tree) => !!tree.getState().dnd,
      handler: (_, tree) => {
        moveDragPosition(tree, true);
      }
    },
    dragDown: {
      hotkey: "ArrowDown",
      preventDefault: true,
      isEnabled: (tree) => !!tree.getState().dnd,
      handler: (_, tree) => {
        moveDragPosition(tree, false);
      }
    },
    cancelDrag: {
      hotkey: "Escape",
      isEnabled: (tree) => !!tree.getState().dnd,
      handler: (_, tree) => {
        tree.stopKeyboardDrag();
      }
    },
    completeDrag: {
      hotkey: "Enter",
      preventDefault: true,
      isEnabled: (tree) => !!tree.getState().dnd,
      handler: (e, tree) => __awaiter5(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d;
        e.stopPropagation();
        const dataRef = tree.getDataRef();
        const target = tree.getDragTarget();
        const dataTransfer = (_a = dataRef.current.kDndDataTransfer) !== null && _a !== void 0 ? _a : null;
        if (!target || !canDrop(dataTransfer, target, tree)) {
          return;
        }
        const config = tree.getConfig();
        const draggedItems = (_b = tree.getState().dnd) === null || _b === void 0 ? void 0 : _b.draggedItems;
        dataRef.current.lastDragCode = void 0;
        tree.applySubStateUpdate("dnd", null);
        if (draggedItems) {
          yield (_c = config.onDrop) === null || _c === void 0 ? void 0 : _c.call(config, draggedItems, target);
          tree.getItemInstance(draggedItems[0].getId()).setFocused();
        } else if (dataTransfer) {
          yield (_d = config.onDropForeignDragObject) === null || _d === void 0 ? void 0 : _d.call(config, dataTransfer, target);
        }
        tree.applySubStateUpdate("assistiveDndState", AssistiveDndState.Completed);
      })
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/features/search/feature.js
var searchFeature = {
  key: "search",
  getInitialState: (initialState) => Object.assign({ search: null }, initialState),
  getDefaultConfig: (defaultConfig, tree) => Object.assign({ setSearch: makeStateUpdater("search", tree), isSearchMatchingItem: (search, item) => search.length > 0 && item.getItemName().toLowerCase().includes(search.toLowerCase()) }, defaultConfig),
  stateHandlerNames: {
    search: "setSearch"
  },
  treeInstance: {
    setSearch: ({ tree }, search) => {
      var _a;
      tree.applySubStateUpdate("search", search);
      (_a = tree.getItems().find((item) => {
        var _a2, _b;
        return (_b = (_a2 = tree.getConfig()).isSearchMatchingItem) === null || _b === void 0 ? void 0 : _b.call(_a2, tree.getSearchValue(), item);
      })) === null || _a === void 0 ? void 0 : _a.setFocused();
    },
    openSearch: ({ tree }, initialValue = "") => {
      var _a, _b;
      tree.setSearch(initialValue);
      (_b = (_a = tree.getConfig()).onOpenSearch) === null || _b === void 0 ? void 0 : _b.call(_a);
      setTimeout(() => {
        var _a2;
        (_a2 = tree.getDataRef().current.searchInput) === null || _a2 === void 0 ? void 0 : _a2.focus();
      });
    },
    closeSearch: ({ tree }) => {
      var _a, _b;
      tree.setSearch(null);
      (_b = (_a = tree.getConfig()).onCloseSearch) === null || _b === void 0 ? void 0 : _b.call(_a);
      tree.updateDomFocus();
    },
    isSearchOpen: ({ tree }) => tree.getState().search !== null,
    getSearchValue: ({ tree }) => tree.getState().search || "",
    registerSearchInputElement: ({ tree }, element) => {
      const dataRef = tree.getDataRef();
      dataRef.current.searchInput = element;
      if (element && dataRef.current.keydownHandler) {
        element.addEventListener("keydown", dataRef.current.keydownHandler);
      }
    },
    getSearchInputElement: ({ tree }) => {
      var _a;
      return (_a = tree.getDataRef().current.searchInput) !== null && _a !== void 0 ? _a : null;
    },
    // TODO memoize with propMemoizationFeature
    getSearchInputElementProps: ({ tree }) => ({
      value: tree.getSearchValue(),
      onChange: (e) => tree.setSearch(e.target.value),
      onBlur: () => tree.closeSearch(),
      ref: tree.registerSearchInputElement
    }),
    getSearchMatchingItems: memo(({ tree }) => [
      tree.getSearchValue(),
      tree.getItems(),
      tree.getConfig().isSearchMatchingItem
    ], (search, items, isSearchMatchingItem) => items.filter((item) => search && (isSearchMatchingItem === null || isSearchMatchingItem === void 0 ? void 0 : isSearchMatchingItem(search, item))))
  },
  itemInstance: {
    isMatchingSearch: ({ tree, item }) => tree.getSearchMatchingItems().some((i) => i.getId() === item.getId())
  },
  hotkeys: {
    openSearch: {
      hotkey: "LetterOrNumber",
      preventDefault: true,
      // TODO make true default
      isEnabled: (tree) => !tree.isSearchOpen(),
      handler: (e, tree) => {
        e.stopPropagation();
        tree.openSearch(e.key);
      }
    },
    closeSearch: {
      // TODO allow multiple, i.e. Enter
      hotkey: "Escape",
      allowWhenInputFocused: true,
      isEnabled: (tree) => tree.isSearchOpen(),
      handler: (e, tree) => {
        tree.closeSearch();
      }
    },
    submitSearch: {
      hotkey: "Enter",
      allowWhenInputFocused: true,
      isEnabled: (tree) => tree.isSearchOpen(),
      handler: (e, tree) => {
        tree.closeSearch();
        tree.setSelectedItems([tree.getFocusedItem().getId()]);
      }
    },
    nextSearchItem: {
      hotkey: "ArrowDown",
      allowWhenInputFocused: true,
      canRepeat: true,
      isEnabled: (tree) => tree.isSearchOpen(),
      handler: (e, tree) => {
        const focusItem = tree.getSearchMatchingItems().find((item) => item.getItemMeta().index > tree.getFocusedItem().getItemMeta().index);
        focusItem === null || focusItem === void 0 ? void 0 : focusItem.setFocused();
        focusItem === null || focusItem === void 0 ? void 0 : focusItem.scrollTo({ block: "nearest", inline: "nearest" });
      }
    },
    previousSearchItem: {
      hotkey: "ArrowUp",
      allowWhenInputFocused: true,
      canRepeat: true,
      isEnabled: (tree) => tree.isSearchOpen(),
      handler: (e, tree) => {
        const focusItem = [...tree.getSearchMatchingItems()].reverse().find((item) => item.getItemMeta().index < tree.getFocusedItem().getItemMeta().index);
        focusItem === null || focusItem === void 0 ? void 0 : focusItem.setFocused();
        focusItem === null || focusItem === void 0 ? void 0 : focusItem.scrollTo({ block: "nearest", inline: "nearest" });
      }
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/features/renaming/feature.js
var renamingFeature = {
  key: "renaming",
  overwrites: ["drag-and-drop"],
  getDefaultConfig: (defaultConfig, tree) => Object.assign({ setRenamingItem: makeStateUpdater("renamingItem", tree), setRenamingValue: makeStateUpdater("renamingValue", tree), canRename: () => true }, defaultConfig),
  stateHandlerNames: {
    renamingItem: "setRenamingItem",
    renamingValue: "setRenamingValue"
  },
  treeInstance: {
    getRenamingItem: ({ tree }) => {
      const itemId = tree.getState().renamingItem;
      return itemId ? tree.getItemInstance(itemId) : null;
    },
    getRenamingValue: ({ tree }) => tree.getState().renamingValue || "",
    abortRenaming: ({ tree }) => {
      tree.applySubStateUpdate("renamingItem", null);
      tree.updateDomFocus();
    },
    completeRenaming: ({ tree }) => {
      var _a;
      const config = tree.getConfig();
      const item = tree.getRenamingItem();
      if (item) {
        (_a = config.onRename) === null || _a === void 0 ? void 0 : _a.call(config, item, tree.getState().renamingValue || "");
      }
      tree.applySubStateUpdate("renamingItem", null);
      tree.updateDomFocus();
    },
    isRenamingItem: ({ tree }) => !!tree.getState().renamingItem
  },
  itemInstance: {
    startRenaming: ({ tree, item, itemId }) => {
      if (!item.canRename()) {
        return;
      }
      tree.applySubStateUpdate("renamingItem", itemId);
      tree.applySubStateUpdate("renamingValue", item.getItemName());
    },
    getRenameInputProps: ({ tree }) => ({
      ref: (r) => r === null || r === void 0 ? void 0 : r.focus(),
      onBlur: () => tree.abortRenaming(),
      value: tree.getRenamingValue(),
      onChange: (e) => {
        var _a;
        tree.applySubStateUpdate("renamingValue", (_a = e.target) === null || _a === void 0 ? void 0 : _a.value);
      }
    }),
    canRename: ({ tree, item }) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = tree.getConfig()).canRename) === null || _b === void 0 ? void 0 : _b.call(_a, item)) !== null && _c !== void 0 ? _c : true;
    },
    isRenaming: ({ tree, item }) => item.getId() === tree.getState().renamingItem,
    getProps: ({ prev, item }) => {
      var _a;
      const isRenaming = item.isRenaming();
      const prevProps = (_a = prev === null || prev === void 0 ? void 0 : prev()) !== null && _a !== void 0 ? _a : {};
      return isRenaming ? Object.assign(Object.assign({}, prevProps), { draggable: false, onDragStart: () => {
      } }) : prevProps;
    }
  },
  hotkeys: {
    renameItem: {
      hotkey: "F2",
      handler: (e, tree) => {
        tree.getFocusedItem().startRenaming();
      }
    },
    abortRenaming: {
      hotkey: "Escape",
      allowWhenInputFocused: true,
      isEnabled: (tree) => tree.isRenamingItem(),
      handler: (e, tree) => {
        tree.abortRenaming();
      }
    },
    completeRenaming: {
      hotkey: "Enter",
      allowWhenInputFocused: true,
      isEnabled: (tree) => tree.isRenamingItem(),
      handler: (e, tree) => {
        tree.completeRenaming();
      }
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/features/expand-all/feature.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var expandAllFeature = {
  key: "expand-all",
  treeInstance: {
    expandAll: (_a, cancelToken_1) => __awaiter6(void 0, [_a, cancelToken_1], void 0, function* ({ tree }, cancelToken) {
      yield Promise.all(tree.getItems().map((item) => item.expandAll(cancelToken)));
    }),
    collapseAll: ({ tree }) => {
      tree.applySubStateUpdate("expandedItems", []);
      tree.rebuildTree();
    }
  },
  itemInstance: {
    expandAll: (_a, cancelToken_1) => __awaiter6(void 0, [_a, cancelToken_1], void 0, function* ({ tree, item }, cancelToken) {
      if (cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.current) {
        return;
      }
      if (!item.isFolder()) {
        return;
      }
      item.expand();
      yield tree.waitForItemChildrenLoaded(item.getId());
      yield Promise.all(item.getChildren().map((child) => __awaiter6(void 0, void 0, void 0, function* () {
        yield tree.waitForItemChildrenLoaded(item.getId());
        yield child === null || child === void 0 ? void 0 : child.expandAll(cancelToken);
      })));
    }),
    collapseAll: ({ item }) => {
      if (!item.isExpanded())
        return;
      for (const child of item.getChildren()) {
        child === null || child === void 0 ? void 0 : child.collapseAll();
      }
      item.collapse();
    }
  },
  hotkeys: {
    expandSelected: {
      hotkey: "Control+Shift+Plus",
      handler: (_, tree) => __awaiter6(void 0, void 0, void 0, function* () {
        const cancelToken = { current: false };
        const cancelHandler = (e) => {
          if (e.code === "Escape") {
            cancelToken.current = true;
          }
        };
        document.addEventListener("keydown", cancelHandler);
        yield Promise.all(tree.getSelectedItems().map((item) => item.expandAll(cancelToken)));
        document.removeEventListener("keydown", cancelHandler);
      })
    },
    collapseSelected: {
      hotkey: "Control+Shift+Minus",
      handler: (_, tree) => {
        tree.getSelectedItems().forEach((item) => item.collapseAll());
      }
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/features/prop-memoization/feature.js
var memoize = (props, memoizedProps) => {
  for (const key in props) {
    if (typeof props[key] === "function") {
      if (memoizedProps && key in memoizedProps) {
        props[key] = memoizedProps[key];
      } else {
        memoizedProps[key] = props[key];
      }
    }
  }
  return props;
};
var propMemoizationFeature = {
  key: "prop-memoization",
  overwrites: [
    "main",
    "async-data-loader",
    "sync-data-loader",
    "drag-and-drop",
    "expand-all",
    "hotkeys-core",
    "renaming",
    "search",
    "selection"
  ],
  treeInstance: {
    getContainerProps: ({ tree, prev }, treeLabel) => {
      var _a, _b, _c;
      var _d, _e;
      const dataRef = tree.getDataRef();
      const props = (_a = prev === null || prev === void 0 ? void 0 : prev(treeLabel)) !== null && _a !== void 0 ? _a : {};
      (_b = (_d = dataRef.current).memo) !== null && _b !== void 0 ? _b : _d.memo = {};
      (_c = (_e = dataRef.current.memo).tree) !== null && _c !== void 0 ? _c : _e.tree = {};
      return memoize(props, dataRef.current.memo.tree);
    },
    getSearchInputElementProps: ({ tree, prev }) => {
      var _a, _b, _c;
      var _d, _e;
      const dataRef = tree.getDataRef();
      const props = (_a = prev === null || prev === void 0 ? void 0 : prev()) !== null && _a !== void 0 ? _a : {};
      (_b = (_d = dataRef.current).memo) !== null && _b !== void 0 ? _b : _d.memo = {};
      (_c = (_e = dataRef.current.memo).search) !== null && _c !== void 0 ? _c : _e.search = {};
      return memoize(props, dataRef.current.memo.search);
    }
  },
  itemInstance: {
    getProps: ({ item, prev }) => {
      var _a, _b, _c;
      var _d, _e;
      const dataRef = item.getDataRef();
      const props = (_a = prev === null || prev === void 0 ? void 0 : prev()) !== null && _a !== void 0 ? _a : {};
      (_b = (_d = dataRef.current).memo) !== null && _b !== void 0 ? _b : _d.memo = {};
      (_c = (_e = dataRef.current.memo).item) !== null && _c !== void 0 ? _c : _e.item = {};
      return memoize(props, dataRef.current.memo.item);
    },
    getRenameInputProps: ({ item, prev }) => {
      var _a, _b, _c;
      var _d, _e;
      const dataRef = item.getDataRef();
      const props = (_a = prev === null || prev === void 0 ? void 0 : prev()) !== null && _a !== void 0 ? _a : {};
      (_b = (_d = dataRef.current).memo) !== null && _b !== void 0 ? _b : _d.memo = {};
      (_c = (_e = dataRef.current.memo).rename) !== null && _c !== void 0 ? _c : _e.rename = {};
      return memoize(props, dataRef.current.memo.rename);
    }
  }
};

// node_modules/@headless-tree/core/lib/esm/utilities/remove-items-from-parents.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var removeItemsFromParents = (movedItems, onChangeChildren) => __awaiter7(void 0, void 0, void 0, function* () {
  const movedItemsIds = movedItems.map((item) => item.getId());
  const uniqueParents = [
    ...new Set(movedItems.map((item) => item.getParent()))
  ];
  for (const parent of uniqueParents) {
    const siblings = parent === null || parent === void 0 ? void 0 : parent.getChildren();
    if (siblings && parent) {
      const newChildren = siblings.filter((sibling) => !movedItemsIds.includes(sibling.getId())).map((i) => i.getId());
      yield onChangeChildren(parent, newChildren);
      if (parent && "updateCachedChildrenIds" in parent) {
        parent === null || parent === void 0 ? void 0 : parent.updateCachedChildrenIds(newChildren);
      }
    }
  }
  movedItems[0].getTree().rebuildTree();
});

// node_modules/@headless-tree/core/lib/esm/utilities/insert-items-at-target.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var insertItemsAtTarget = (itemIds, target, onChangeChildren) => __awaiter8(void 0, void 0, void 0, function* () {
  yield target.item.getTree().waitForItemChildrenLoaded(target.item.getId());
  const oldChildrenIds = target.item.getTree().retrieveChildrenIds(target.item.getId());
  if (!("childIndex" in target)) {
    const newChildren2 = [...oldChildrenIds, ...itemIds];
    yield onChangeChildren(target.item, newChildren2);
    if (target.item && "updateCachedChildrenIds" in target.item) {
      target.item.updateCachedChildrenIds(newChildren2);
    }
    target.item.getTree().rebuildTree();
    return;
  }
  const newChildren = [
    ...oldChildrenIds.slice(0, target.insertionIndex),
    ...itemIds,
    ...oldChildrenIds.slice(target.insertionIndex)
  ];
  yield onChangeChildren(target.item, newChildren);
  if (target.item && "updateCachedChildrenIds" in target.item) {
    target.item.updateCachedChildrenIds(newChildren);
  }
  target.item.getTree().rebuildTree();
});

// node_modules/@headless-tree/core/lib/esm/utilities/create-on-drop-handler.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var createOnDropHandler = (onChangeChildren) => (items, target) => __awaiter9(void 0, void 0, void 0, function* () {
  const itemIds = items.map((item) => item.getId());
  yield removeItemsFromParents(items, onChangeChildren);
  yield insertItemsAtTarget(itemIds, target, onChangeChildren);
});

// node_modules/@headless-tree/core/lib/esm/core/build-proxified-instance.js
var noop = () => {
};
var findPrevInstanceMethod = (features, instanceType, methodKey, featureSearchIndex) => {
  var _a;
  for (let i = featureSearchIndex; i >= 0; i--) {
    const feature = features[i];
    const itemInstanceMethod = (_a = feature[instanceType]) === null || _a === void 0 ? void 0 : _a[methodKey];
    if (itemInstanceMethod) {
      return i;
    }
  }
  return null;
};
var invokeInstanceMethod = (features, instanceType, opts, methodKey, featureIndex, args) => {
  var _a;
  const prevIndex = findPrevInstanceMethod(features, instanceType, methodKey, featureIndex - 1);
  const itemInstanceMethod = (_a = features[featureIndex][instanceType]) === null || _a === void 0 ? void 0 : _a[methodKey];
  return itemInstanceMethod(Object.assign(Object.assign({}, opts), { prev: prevIndex !== null ? (...newArgs) => invokeInstanceMethod(features, instanceType, opts, methodKey, prevIndex, newArgs) : null }), ...args);
};
var buildProxiedInstance = (features, instanceType, buildOpts) => {
  const opts = {};
  const item = new Proxy({}, {
    has(target, key) {
      if (typeof key === "symbol") {
        return false;
      }
      if (key === "toJSON") {
        return false;
      }
      const hasInstanceMethod = findPrevInstanceMethod(features, instanceType, key, features.length - 1);
      return Boolean(hasInstanceMethod);
    },
    get(target, key) {
      if (typeof key === "symbol") {
        return void 0;
      }
      if (key === "toJSON") {
        return {};
      }
      return (...args) => {
        const featureIndex = findPrevInstanceMethod(features, instanceType, key, features.length - 1);
        if (featureIndex === null) {
          throw throwError(`feature missing for method ${key}`);
        }
        return invokeInstanceMethod(features, instanceType, opts, key, featureIndex, args);
      };
    }
  });
  Object.assign(opts, buildOpts(item));
  return [item, noop];
};

export {
  makeStateUpdater,
  buildStaticInstance,
  createTree,
  DragTargetPosition,
  AssistiveDndState,
  CheckedState,
  selectionFeature,
  checkboxesFeature,
  hotkeysCoreFeature,
  asyncDataLoaderFeature,
  syncDataLoaderFeature,
  isOrderedDragTarget,
  dragAndDropFeature,
  keyboardDragAndDropFeature,
  searchFeature,
  renamingFeature,
  expandAllFeature,
  propMemoizationFeature,
  removeItemsFromParents,
  insertItemsAtTarget,
  createOnDropHandler,
  buildProxiedInstance
};
//# sourceMappingURL=chunk-MTDLZPZD.js.map
