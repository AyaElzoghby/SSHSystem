{
  "version": 3,
  "sources": ["../../@headless-tree/core/lib/esm/utils.js", "../../@headless-tree/core/lib/esm/utilities/errors.js", "../../@headless-tree/core/lib/esm/features/tree/feature.js", "../../@headless-tree/core/lib/esm/core/build-static-instance.js", "../../@headless-tree/core/lib/esm/core/create-tree.js", "../../@headless-tree/core/lib/esm/features/drag-and-drop/types.js", "../../@headless-tree/core/lib/esm/features/keyboard-drag-and-drop/types.js", "../../@headless-tree/core/lib/esm/features/checkboxes/types.js", "../../@headless-tree/core/lib/esm/features/selection/feature.js", "../../@headless-tree/core/lib/esm/features/checkboxes/feature.js", "../../@headless-tree/core/lib/esm/features/hotkeys-core/feature.js", "../../@headless-tree/core/lib/esm/features/async-data-loader/feature.js", "../../@headless-tree/core/lib/esm/features/sync-data-loader/feature.js", "../../@headless-tree/core/lib/esm/features/drag-and-drop/utils.js", "../../@headless-tree/core/lib/esm/features/drag-and-drop/feature.js", "../../@headless-tree/core/lib/esm/features/keyboard-drag-and-drop/feature.js", "../../@headless-tree/core/lib/esm/features/search/feature.js", "../../@headless-tree/core/lib/esm/features/renaming/feature.js", "../../@headless-tree/core/lib/esm/features/expand-all/feature.js", "../../@headless-tree/core/lib/esm/features/prop-memoization/feature.js", "../../@headless-tree/core/lib/esm/utilities/remove-items-from-parents.js", "../../@headless-tree/core/lib/esm/utilities/insert-items-at-target.js", "../../@headless-tree/core/lib/esm/utilities/create-on-drop-handler.js", "../../@headless-tree/core/lib/esm/core/build-proxified-instance.js"],
  "sourcesContent": ["export const memo = (deps, fn) => {\n    let value;\n    let oldDeps = null;\n    return (...a) => {\n        const newDeps = deps(...a);\n        if (!value) {\n            value = fn(...newDeps);\n            oldDeps = newDeps;\n            return value;\n        }\n        const match = oldDeps &&\n            oldDeps.length === newDeps.length &&\n            !oldDeps.some((dep, i) => dep !== newDeps[i]);\n        if (match) {\n            return value;\n        }\n        value = fn(...newDeps);\n        oldDeps = newDeps;\n        return value;\n    };\n};\nexport function functionalUpdate(updater, input) {\n    return typeof updater === \"function\"\n        ? updater(input)\n        : updater;\n}\nexport function makeStateUpdater(key, instance) {\n    return (updater) => {\n        instance.setState((old) => {\n            return Object.assign(Object.assign({}, old), { [key]: functionalUpdate(updater, old[key]) });\n        });\n    };\n}\nexport const poll = (fn, interval = 100, timeout = 1000) => new Promise((resolve) => {\n    let clear;\n    const i = setInterval(() => {\n        if (fn()) {\n            resolve();\n            clearInterval(i);\n            clearTimeout(clear);\n        }\n    }, interval);\n    clear = setTimeout(() => {\n        clearInterval(i);\n    }, timeout);\n});\n", "const prefix = \"Headless Tree: \";\nexport const throwError = (message) => Error(prefix + message);\n// eslint-disable-next-line no-console\nexport const logWarning = (message) => console.warn(prefix + message);\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { makeStateUpdater, poll } from \"../../utils\";\nimport { logWarning } from \"../../utilities/errors\";\nexport const treeFeature = {\n    key: \"tree\",\n    getInitialState: (initialState) => (Object.assign({ expandedItems: [], focusedItem: null }, initialState)),\n    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setExpandedItems: makeStateUpdater(\"expandedItems\", tree), setFocusedItem: makeStateUpdater(\"focusedItem\", tree) }, defaultConfig)),\n    stateHandlerNames: {\n        expandedItems: \"setExpandedItems\",\n        focusedItem: \"setFocusedItem\",\n    },\n    treeInstance: {\n        getItemsMeta: ({ tree }) => {\n            const { rootItemId } = tree.getConfig();\n            const { expandedItems } = tree.getState();\n            const flatItems = [];\n            const expandedItemsSet = new Set(expandedItems); // TODO support setting state expandedItems as set instead of array\n            const recursiveAdd = (itemId, path, level, setSize, posInSet) => {\n                var _a;\n                if (path.includes(itemId)) {\n                    logWarning(`Circular reference for ${path.join(\".\")}`);\n                    return;\n                }\n                flatItems.push({\n                    itemId,\n                    level,\n                    index: flatItems.length,\n                    parentId: path.at(-1),\n                    setSize,\n                    posInSet,\n                });\n                if (expandedItemsSet.has(itemId)) {\n                    const children = (_a = tree.retrieveChildrenIds(itemId)) !== null && _a !== void 0 ? _a : [];\n                    let i = 0;\n                    for (const childId of children) {\n                        recursiveAdd(childId, path.concat(itemId), level + 1, children.length, i++);\n                    }\n                }\n            };\n            const children = tree.retrieveChildrenIds(rootItemId);\n            let i = 0;\n            for (const itemId of children) {\n                recursiveAdd(itemId, [rootItemId], 0, children.length, i++);\n            }\n            return flatItems;\n        },\n        getFocusedItem: ({ tree }) => {\n            var _a, _b;\n            return ((_b = tree.getItemInstance((_a = tree.getState().focusedItem) !== null && _a !== void 0 ? _a : \"\")) !== null && _b !== void 0 ? _b : tree.getItems()[0]);\n        },\n        getRootItem: ({ tree }) => {\n            const { rootItemId } = tree.getConfig();\n            return tree.getItemInstance(rootItemId);\n        },\n        focusNextItem: ({ tree }) => {\n            var _a;\n            const focused = tree.getFocusedItem().getItemMeta();\n            if (!focused)\n                return;\n            const nextIndex = Math.min(focused.index + 1, tree.getItems().length - 1);\n            (_a = tree.getItems()[nextIndex]) === null || _a === void 0 ? void 0 : _a.setFocused();\n        },\n        focusPreviousItem: ({ tree }) => {\n            var _a;\n            const focused = tree.getFocusedItem().getItemMeta();\n            if (!focused)\n                return;\n            const nextIndex = Math.max(focused.index - 1, 0);\n            (_a = tree.getItems()[nextIndex]) === null || _a === void 0 ? void 0 : _a.setFocused();\n        },\n        updateDomFocus: ({ tree }) => {\n            // Required because if the state is managed outside in react, the state only updated during next render\n            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n                var _a, _b;\n                const focusedItem = tree.getFocusedItem();\n                (_b = (_a = tree.getConfig()).scrollToItem) === null || _b === void 0 ? void 0 : _b.call(_a, focusedItem);\n                yield poll(() => focusedItem.getElement() !== null, 20);\n                const focusedElement = focusedItem.getElement();\n                if (!focusedElement)\n                    return;\n                focusedElement.focus();\n            }));\n        },\n        getContainerProps: ({ prev, tree }, treeLabel) => (Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { role: \"tree\", \"aria-label\": treeLabel !== null && treeLabel !== void 0 ? treeLabel : \"\", ref: tree.registerElement })),\n        // relevant for hotkeys of this feature\n        isSearchOpen: () => false,\n    },\n    itemInstance: {\n        scrollTo: (_a, scrollIntoViewArg_1) => __awaiter(void 0, [_a, scrollIntoViewArg_1], void 0, function* ({ tree, item }, scrollIntoViewArg) {\n            var _b, _c, _d;\n            (_c = (_b = tree.getConfig()).scrollToItem) === null || _c === void 0 ? void 0 : _c.call(_b, item);\n            yield poll(() => item.getElement() !== null, 20);\n            (_d = item.getElement()) === null || _d === void 0 ? void 0 : _d.scrollIntoView(scrollIntoViewArg);\n        }),\n        getId: ({ itemId }) => itemId,\n        getKey: ({ itemId }) => itemId, // TODO apply to all stories to use\n        getProps: ({ item, prev }) => {\n            const itemMeta = item.getItemMeta();\n            return Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { ref: item.registerElement, role: \"treeitem\", \"aria-setsize\": itemMeta.setSize, \"aria-posinset\": itemMeta.posInSet, \"aria-selected\": \"false\", \"aria-label\": item.getItemName(), \"aria-level\": itemMeta.level, tabIndex: item.isFocused() ? 0 : -1, onClick: (e) => {\n                    item.setFocused();\n                    item.primaryAction();\n                    if (e.ctrlKey || e.shiftKey || e.metaKey) {\n                        return;\n                    }\n                    if (!item.isFolder()) {\n                        return;\n                    }\n                    if (item.isExpanded()) {\n                        item.collapse();\n                    }\n                    else {\n                        item.expand();\n                    }\n                } });\n        },\n        expand: ({ tree, item, itemId }) => {\n            var _a;\n            if (!item.isFolder()) {\n                return;\n            }\n            if ((_a = tree.getState().loadingItemChildrens) === null || _a === void 0 ? void 0 : _a.includes(itemId)) {\n                return;\n            }\n            tree.applySubStateUpdate(\"expandedItems\", (expandedItems) => [\n                ...expandedItems,\n                itemId,\n            ]);\n            tree.rebuildTree();\n        },\n        collapse: ({ tree, item, itemId }) => {\n            if (!item.isFolder()) {\n                return;\n            }\n            tree.applySubStateUpdate(\"expandedItems\", (expandedItems) => expandedItems.filter((id) => id !== itemId));\n            tree.rebuildTree();\n        },\n        getItemData: ({ tree, itemId }) => tree.retrieveItemData(itemId),\n        equals: ({ item }, other) => item.getId() === (other === null || other === void 0 ? void 0 : other.getId()),\n        isExpanded: ({ tree, itemId }) => tree.getState().expandedItems.includes(itemId),\n        isDescendentOf: ({ item }, parentId) => {\n            const parent = item.getParent();\n            return Boolean((parent === null || parent === void 0 ? void 0 : parent.getId()) === parentId || (parent === null || parent === void 0 ? void 0 : parent.isDescendentOf(parentId)));\n        },\n        isFocused: ({ tree, item, itemId }) => tree.getState().focusedItem === itemId ||\n            (tree.getState().focusedItem === null && item.getItemMeta().index === 0),\n        isFolder: ({ tree, item }) => item.getItemMeta().level === -1 ||\n            tree.getConfig().isItemFolder(item),\n        getItemName: ({ tree, item }) => {\n            const config = tree.getConfig();\n            return config.getItemName(item);\n        },\n        setFocused: ({ tree, itemId }) => {\n            tree.applySubStateUpdate(\"focusedItem\", itemId);\n        },\n        primaryAction: ({ tree, item }) => { var _a, _b; return (_b = (_a = tree.getConfig()).onPrimaryAction) === null || _b === void 0 ? void 0 : _b.call(_a, item); },\n        getParent: ({ tree, item }) => item.getItemMeta().parentId\n            ? tree.getItemInstance(item.getItemMeta().parentId)\n            : undefined,\n        getIndexInParent: ({ item }) => item.getItemMeta().posInSet,\n        getChildren: ({ tree, itemId }) => tree.retrieveChildrenIds(itemId).map((id) => tree.getItemInstance(id)),\n        getTree: ({ tree }) => tree,\n        getItemAbove: ({ tree, item }) => tree.getItems()[item.getItemMeta().index - 1],\n        getItemBelow: ({ tree, item }) => tree.getItems()[item.getItemMeta().index + 1],\n    },\n    hotkeys: {\n        focusNextItem: {\n            hotkey: \"ArrowDown\",\n            canRepeat: true,\n            preventDefault: true,\n            isEnabled: (tree) => { var _a, _b; return !((_b = (_a = tree.isSearchOpen) === null || _a === void 0 ? void 0 : _a.call(tree)) !== null && _b !== void 0 ? _b : false) && !tree.getState().dnd; }, // TODO what happens when the feature doesnt exist? proxy method still claims to exist\n            handler: (e, tree) => {\n                tree.focusNextItem();\n                tree.updateDomFocus();\n            },\n        },\n        focusPreviousItem: {\n            hotkey: \"ArrowUp\",\n            canRepeat: true,\n            preventDefault: true,\n            isEnabled: (tree) => { var _a, _b; return !((_b = (_a = tree.isSearchOpen) === null || _a === void 0 ? void 0 : _a.call(tree)) !== null && _b !== void 0 ? _b : false) && !tree.getState().dnd; },\n            handler: (e, tree) => {\n                tree.focusPreviousItem();\n                tree.updateDomFocus();\n            },\n        },\n        expandOrDown: {\n            hotkey: \"ArrowRight\",\n            canRepeat: true,\n            handler: (e, tree) => {\n                const item = tree.getFocusedItem();\n                if (item.isExpanded() || !item.isFolder()) {\n                    tree.focusNextItem();\n                    tree.updateDomFocus();\n                }\n                else {\n                    item.expand();\n                }\n            },\n        },\n        collapseOrUp: {\n            hotkey: \"ArrowLeft\",\n            canRepeat: true,\n            handler: (e, tree) => {\n                var _a;\n                const item = tree.getFocusedItem();\n                if ((!item.isExpanded() || !item.isFolder()) &&\n                    item.getItemMeta().level !== 0) {\n                    (_a = item.getParent()) === null || _a === void 0 ? void 0 : _a.setFocused();\n                    tree.updateDomFocus();\n                }\n                else {\n                    item.collapse();\n                }\n            },\n        },\n        focusFirstItem: {\n            hotkey: \"Home\",\n            handler: (e, tree) => {\n                var _a;\n                (_a = tree.getItems()[0]) === null || _a === void 0 ? void 0 : _a.setFocused();\n                tree.updateDomFocus();\n            },\n        },\n        focusLastItem: {\n            hotkey: \"End\",\n            handler: (e, tree) => {\n                var _a;\n                (_a = tree.getItems()[tree.getItems().length - 1]) === null || _a === void 0 ? void 0 : _a.setFocused();\n                tree.updateDomFocus();\n            },\n        },\n    },\n};\n", "/* eslint-disable no-continue,no-labels,no-extra-label */\nexport const buildStaticInstance = (features, instanceType, buildOpts) => {\n    const instance = {};\n    const finalize = () => {\n        const opts = buildOpts(instance);\n        featureLoop: for (let i = 0; i < features.length; i++) {\n            // Loop goes in forward order, each features overwrite previous ones and wraps those in a prev() fn\n            const definition = features[i][instanceType];\n            if (!definition)\n                continue featureLoop;\n            methodLoop: for (const [key, method] of Object.entries(definition)) {\n                if (!method)\n                    continue methodLoop;\n                const prev = instance[key];\n                instance[key] = (...args) => {\n                    return method(Object.assign(Object.assign({}, opts), { prev }), ...args);\n                };\n            }\n        }\n    };\n    return [instance, finalize];\n};\n", "import { treeFeature } from \"../features/tree/feature\";\nimport { buildStaticInstance } from \"./build-static-instance\";\nimport { throwError } from \"../utilities/errors\";\nconst verifyFeatures = (features) => {\n    var _a;\n    const loadedFeatures = features === null || features === void 0 ? void 0 : features.map((feature) => feature.key);\n    for (const feature of features !== null && features !== void 0 ? features : []) {\n        const missingDependency = (_a = feature.deps) === null || _a === void 0 ? void 0 : _a.find((dep) => !(loadedFeatures === null || loadedFeatures === void 0 ? void 0 : loadedFeatures.includes(dep)));\n        if (missingDependency) {\n            throw throwError(`${feature.key} needs ${missingDependency}`);\n        }\n    }\n};\n// Check all possible pairs and sort the array\nconst exhaustiveSort = (arr, compareFn) => {\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if (compareFn(arr[j], arr[i]) < 0) {\n                [arr[i], arr[j]] = [arr[j], arr[i]];\n            }\n        }\n    }\n    return arr;\n};\nconst compareFeatures = (originalOrder) => (feature1, feature2) => {\n    var _a, _b;\n    if (feature2.key && ((_a = feature1.overwrites) === null || _a === void 0 ? void 0 : _a.includes(feature2.key))) {\n        return 1;\n    }\n    if (feature1.key && ((_b = feature2.overwrites) === null || _b === void 0 ? void 0 : _b.includes(feature1.key))) {\n        return -1;\n    }\n    return originalOrder.indexOf(feature1) - originalOrder.indexOf(feature2);\n};\nconst sortFeatures = (features = []) => exhaustiveSort(features, compareFeatures(features));\nexport const createTree = (initialConfig) => {\n    var _a, _b, _c, _d;\n    const buildInstance = (_a = initialConfig.instanceBuilder) !== null && _a !== void 0 ? _a : buildStaticInstance;\n    const additionalFeatures = [\n        treeFeature,\n        ...sortFeatures(initialConfig.features),\n    ];\n    verifyFeatures(additionalFeatures);\n    const features = [...additionalFeatures];\n    const [treeInstance, finalizeTree] = buildInstance(features, \"treeInstance\", (tree) => ({ tree }));\n    let state = additionalFeatures.reduce((acc, feature) => { var _a, _b; return (_b = (_a = feature.getInitialState) === null || _a === void 0 ? void 0 : _a.call(feature, acc, treeInstance)) !== null && _b !== void 0 ? _b : acc; }, (_c = (_b = initialConfig.initialState) !== null && _b !== void 0 ? _b : initialConfig.state) !== null && _c !== void 0 ? _c : {});\n    let config = additionalFeatures.reduce((acc, feature) => { var _a, _b; return (_b = (_a = feature.getDefaultConfig) === null || _a === void 0 ? void 0 : _a.call(feature, acc, treeInstance)) !== null && _b !== void 0 ? _b : acc; }, initialConfig);\n    const stateHandlerNames = additionalFeatures.reduce((acc, feature) => (Object.assign(Object.assign({}, acc), feature.stateHandlerNames)), {});\n    let treeElement;\n    const treeDataRef = { current: {} };\n    const itemInstancesMap = {};\n    let itemInstances = [];\n    const itemElementsMap = {};\n    const itemDataRefs = {};\n    let itemMetaMap = {};\n    const hotkeyPresets = {};\n    const rebuildItemMeta = () => {\n        // TODO can we find a way to only run this for the changed substructure?\n        itemInstances = [];\n        itemMetaMap = {};\n        const [rootInstance, finalizeRootInstance] = buildInstance(features, \"itemInstance\", (item) => ({ item, tree: treeInstance, itemId: config.rootItemId }));\n        finalizeRootInstance();\n        itemInstancesMap[config.rootItemId] = rootInstance;\n        itemMetaMap[config.rootItemId] = {\n            itemId: config.rootItemId,\n            index: -1,\n            parentId: null,\n            level: -1,\n            posInSet: 0,\n            setSize: 1,\n        };\n        for (const item of treeInstance.getItemsMeta()) {\n            itemMetaMap[item.itemId] = item;\n            if (!itemInstancesMap[item.itemId]) {\n                const [instance, finalizeInstance] = buildInstance(features, \"itemInstance\", (instance) => ({\n                    item: instance,\n                    tree: treeInstance,\n                    itemId: item.itemId,\n                }));\n                finalizeInstance();\n                itemInstancesMap[item.itemId] = instance;\n                itemInstances.push(instance);\n            }\n            else {\n                itemInstances.push(itemInstancesMap[item.itemId]);\n            }\n        }\n    };\n    const eachFeature = (fn) => {\n        for (const feature of additionalFeatures) {\n            fn(feature);\n        }\n    };\n    const mainFeature = {\n        key: \"main\",\n        treeInstance: {\n            getState: () => state,\n            setState: ({}, updater) => {\n                var _a;\n                // Not necessary, since I think the subupdate below keeps the state fresh anyways?\n                // state = typeof updater === \"function\" ? updater(state) : updater;\n                (_a = config.setState) === null || _a === void 0 ? void 0 : _a.call(config, state); // TODO this cant be right... This doesnt allow external state updates\n                // TODO this is never used, remove\n            },\n            applySubStateUpdate: ({}, stateName, updater) => {\n                state[stateName] =\n                    typeof updater === \"function\" ? updater(state[stateName]) : updater;\n                const externalStateSetter = config[stateHandlerNames[stateName]];\n                externalStateSetter === null || externalStateSetter === void 0 ? void 0 : externalStateSetter(state[stateName]);\n            },\n            buildItemInstance: ({}, itemId) => {\n                const [instance, finalizeInstance] = buildInstance(features, \"itemInstance\", (instance) => ({\n                    item: instance,\n                    tree: treeInstance,\n                    itemId,\n                }));\n                finalizeInstance();\n                return instance;\n            },\n            // TODO rebuildSubTree: (itemId: string) => void;\n            rebuildTree: () => {\n                var _a;\n                rebuildItemMeta();\n                (_a = config.setState) === null || _a === void 0 ? void 0 : _a.call(config, state);\n            },\n            getConfig: () => config,\n            setConfig: (_, updater) => {\n                var _a, _b, _c;\n                const newConfig = typeof updater === \"function\" ? updater(config) : updater;\n                const hasChangedExpandedItems = ((_a = newConfig.state) === null || _a === void 0 ? void 0 : _a.expandedItems) &&\n                    ((_b = newConfig.state) === null || _b === void 0 ? void 0 : _b.expandedItems) !== state.expandedItems;\n                config = newConfig;\n                if (newConfig.state) {\n                    state = Object.assign(Object.assign({}, state), newConfig.state);\n                }\n                if (hasChangedExpandedItems) {\n                    // if expanded items where changed from the outside\n                    rebuildItemMeta();\n                    (_c = config.setState) === null || _c === void 0 ? void 0 : _c.call(config, state);\n                }\n            },\n            getItemInstance: ({}, itemId) => itemInstancesMap[itemId],\n            getItems: () => itemInstances,\n            registerElement: ({}, element) => {\n                if (treeElement === element) {\n                    return;\n                }\n                if (treeElement && !element) {\n                    eachFeature((feature) => { var _a; return (_a = feature.onTreeUnmount) === null || _a === void 0 ? void 0 : _a.call(feature, treeInstance, treeElement); });\n                }\n                else if (!treeElement && element) {\n                    eachFeature((feature) => { var _a; return (_a = feature.onTreeMount) === null || _a === void 0 ? void 0 : _a.call(feature, treeInstance, element); });\n                }\n                treeElement = element;\n            },\n            getElement: () => treeElement,\n            getDataRef: () => treeDataRef,\n            getHotkeyPresets: () => hotkeyPresets,\n        },\n        itemInstance: {\n            registerElement: ({ itemId, item }, element) => {\n                if (itemElementsMap[itemId] === element) {\n                    return;\n                }\n                const oldElement = itemElementsMap[itemId];\n                if (oldElement && !element) {\n                    eachFeature((feature) => { var _a; return (_a = feature.onItemUnmount) === null || _a === void 0 ? void 0 : _a.call(feature, item, oldElement, treeInstance); });\n                }\n                else if (!oldElement && element) {\n                    eachFeature((feature) => { var _a; return (_a = feature.onItemMount) === null || _a === void 0 ? void 0 : _a.call(feature, item, element, treeInstance); });\n                }\n                itemElementsMap[itemId] = element;\n            },\n            getElement: ({ itemId }) => itemElementsMap[itemId],\n            // eslint-disable-next-line no-return-assign\n            getDataRef: ({ itemId }) => { var _a; return ((_a = itemDataRefs[itemId]) !== null && _a !== void 0 ? _a : (itemDataRefs[itemId] = { current: {} })); },\n            getItemMeta: ({ itemId }) => itemMetaMap[itemId],\n        },\n    };\n    features.unshift(mainFeature);\n    for (const feature of features) {\n        Object.assign(hotkeyPresets, (_d = feature.hotkeys) !== null && _d !== void 0 ? _d : {});\n    }\n    finalizeTree();\n    return treeInstance;\n};\n", "export var DragTargetPosition;\n(function (DragTargetPosition) {\n    DragTargetPosition[\"Top\"] = \"top\";\n    DragTargetPosition[\"Bottom\"] = \"bottom\";\n    DragTargetPosition[\"Item\"] = \"item\";\n})(DragTargetPosition || (DragTargetPosition = {}));\n", "export var AssistiveDndState;\n(function (AssistiveDndState) {\n    AssistiveDndState[AssistiveDndState[\"None\"] = 0] = \"None\";\n    AssistiveDndState[AssistiveDndState[\"Started\"] = 1] = \"Started\";\n    AssistiveDndState[AssistiveDndState[\"Dragging\"] = 2] = \"Dragging\";\n    AssistiveDndState[AssistiveDndState[\"Completed\"] = 3] = \"Completed\";\n    AssistiveDndState[AssistiveDndState[\"Aborted\"] = 4] = \"Aborted\";\n})(AssistiveDndState || (AssistiveDndState = {}));\n", "export var CheckedState;\n(function (CheckedState) {\n    CheckedState[\"Checked\"] = \"checked\";\n    CheckedState[\"Unchecked\"] = \"unchecked\";\n    CheckedState[\"Indeterminate\"] = \"indeterminate\";\n})(CheckedState || (CheckedState = {}));\n", "import { makeStateUpdater } from \"../../utils\";\nexport const selectionFeature = {\n    key: \"selection\",\n    getInitialState: (initialState) => (Object.assign({ selectedItems: [] }, initialState)),\n    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setSelectedItems: makeStateUpdater(\"selectedItems\", tree) }, defaultConfig)),\n    stateHandlerNames: {\n        selectedItems: \"setSelectedItems\",\n    },\n    treeInstance: {\n        setSelectedItems: ({ tree }, selectedItems) => {\n            tree.applySubStateUpdate(\"selectedItems\", selectedItems);\n        },\n        getSelectedItems: ({ tree }) => {\n            return tree.getState().selectedItems.map(tree.getItemInstance);\n        },\n    },\n    itemInstance: {\n        select: ({ tree, itemId }) => {\n            const { selectedItems } = tree.getState();\n            tree.setSelectedItems(selectedItems.includes(itemId)\n                ? selectedItems\n                : [...selectedItems, itemId]);\n        },\n        deselect: ({ tree, itemId }) => {\n            const { selectedItems } = tree.getState();\n            tree.setSelectedItems(selectedItems.filter((id) => id !== itemId));\n        },\n        isSelected: ({ tree, itemId }) => {\n            const { selectedItems } = tree.getState();\n            return selectedItems.includes(itemId);\n        },\n        selectUpTo: ({ tree, item }, ctrl) => {\n            const indexA = item.getItemMeta().index;\n            // TODO dont use focused item as anchor, but last primary-clicked item\n            const indexB = tree.getFocusedItem().getItemMeta().index;\n            const [a, b] = indexA < indexB ? [indexA, indexB] : [indexB, indexA];\n            const newSelectedItems = tree\n                .getItems()\n                .slice(a, b + 1)\n                .map((treeItem) => treeItem.getItemMeta().itemId);\n            if (!ctrl) {\n                tree.setSelectedItems(newSelectedItems);\n                return;\n            }\n            const { selectedItems } = tree.getState();\n            const uniqueSelectedItems = [\n                ...new Set([...selectedItems, ...newSelectedItems]),\n            ];\n            tree.setSelectedItems(uniqueSelectedItems);\n        },\n        toggleSelect: ({ item }) => {\n            if (item.isSelected()) {\n                item.deselect();\n            }\n            else {\n                item.select();\n            }\n        },\n        getProps: ({ tree, item, prev }) => (Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { \"aria-selected\": item.isSelected() ? \"true\" : \"false\", onClick: (e) => {\n                var _a, _b;\n                if (e.shiftKey) {\n                    item.selectUpTo(e.ctrlKey || e.metaKey);\n                }\n                else if (e.ctrlKey || e.metaKey) {\n                    item.toggleSelect();\n                }\n                else {\n                    tree.setSelectedItems([item.getItemMeta().itemId]);\n                }\n                (_b = (_a = prev === null || prev === void 0 ? void 0 : prev()) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n            } })),\n    },\n    hotkeys: {\n        // setSelectedItem: {\n        //   hotkey: \"space\",\n        //   handler: (e, tree) => {\n        //     tree.setSelectedItems([tree.getFocusedItem().getId()]);\n        //   },\n        // },\n        toggleSelectedItem: {\n            hotkey: \"Control+Space\",\n            preventDefault: true,\n            handler: (_, tree) => {\n                tree.getFocusedItem().toggleSelect();\n            },\n        },\n        selectUpwards: {\n            hotkey: \"Shift+ArrowUp\",\n            handler: (e, tree) => {\n                const focused = tree.getFocusedItem();\n                const above = focused.getItemAbove();\n                if (!above)\n                    return;\n                if (focused.isSelected() && above.isSelected()) {\n                    focused.deselect();\n                }\n                else {\n                    above.select();\n                }\n                above.setFocused();\n                tree.updateDomFocus();\n            },\n        },\n        selectDownwards: {\n            hotkey: \"Shift+ArrowDown\",\n            handler: (e, tree) => {\n                const focused = tree.getFocusedItem();\n                const below = focused.getItemBelow();\n                if (!below)\n                    return;\n                if (focused.isSelected() && below.isSelected()) {\n                    focused.deselect();\n                }\n                else {\n                    below.select();\n                }\n                below.setFocused();\n                tree.updateDomFocus();\n            },\n        },\n        selectAll: {\n            hotkey: \"Control+KeyA\",\n            preventDefault: true,\n            handler: (e, tree) => {\n                tree.setSelectedItems(tree.getItems().map((item) => item.getId()));\n            },\n        },\n    },\n};\n", "import { makeStateUpdater } from \"../../utils\";\nimport { CheckedState } from \"./types\";\nimport { throwError } from \"../../utilities/errors\";\nconst getAllLoadedDescendants = (tree, itemId) => {\n    if (!tree.getConfig().isItemFolder(tree.buildItemInstance(itemId))) {\n        return [itemId];\n    }\n    return tree\n        .retrieveChildrenIds(itemId)\n        .map((child) => getAllLoadedDescendants(tree, child))\n        .flat();\n};\nexport const checkboxesFeature = {\n    key: \"checkboxes\",\n    overwrites: [\"selection\"],\n    getInitialState: (initialState) => (Object.assign({ checkedItems: [] }, initialState)),\n    getDefaultConfig: (defaultConfig, tree) => {\n        var _a;\n        const hasAsyncLoader = (_a = defaultConfig.features) === null || _a === void 0 ? void 0 : _a.some((f) => f.key === \"async-data-loader\");\n        if (hasAsyncLoader && !defaultConfig.canCheckFolders) {\n            throwError(`!canCheckFolders not supported with async trees`);\n        }\n        return Object.assign({ setCheckedItems: makeStateUpdater(\"checkedItems\", tree), canCheckFolders: hasAsyncLoader !== null && hasAsyncLoader !== void 0 ? hasAsyncLoader : false }, defaultConfig);\n    },\n    stateHandlerNames: {\n        checkedItems: \"setCheckedItems\",\n    },\n    treeInstance: {\n        setCheckedItems: ({ tree }, checkedItems) => {\n            tree.applySubStateUpdate(\"checkedItems\", checkedItems);\n        },\n    },\n    itemInstance: {\n        getCheckboxProps: ({ item }) => {\n            const checkedState = item.getCheckedState();\n            return {\n                onChange: item.toggleCheckedState,\n                checked: checkedState === CheckedState.Checked,\n                ref: (r) => {\n                    if (r) {\n                        r.indeterminate = checkedState === CheckedState.Indeterminate;\n                    }\n                },\n            };\n        },\n        toggleCheckedState: ({ item }) => {\n            if (item.getCheckedState() === CheckedState.Checked) {\n                item.setUnchecked();\n            }\n            else {\n                item.setChecked();\n            }\n        },\n        getCheckedState: ({ item, tree, itemId }) => {\n            const { checkedItems } = tree.getState();\n            if (checkedItems.includes(itemId)) {\n                return CheckedState.Checked;\n            }\n            if (item.isFolder() && !tree.getConfig().canCheckFolders) {\n                const descendants = getAllLoadedDescendants(tree, itemId);\n                if (descendants.every((d) => checkedItems.includes(d))) {\n                    return CheckedState.Checked;\n                }\n                if (descendants.some((d) => checkedItems.includes(d))) {\n                    return CheckedState.Indeterminate;\n                }\n            }\n            return CheckedState.Unchecked;\n        },\n        setChecked: ({ item, tree, itemId }) => {\n            if (!item.isFolder() || tree.getConfig().canCheckFolders) {\n                tree.applySubStateUpdate(\"checkedItems\", (items) => [...items, itemId]);\n            }\n            else {\n                tree.applySubStateUpdate(\"checkedItems\", (items) => [\n                    ...items,\n                    ...getAllLoadedDescendants(tree, itemId),\n                ]);\n            }\n        },\n        setUnchecked: ({ item, tree, itemId }) => {\n            if (!item.isFolder() || tree.getConfig().canCheckFolders) {\n                tree.applySubStateUpdate(\"checkedItems\", (items) => items.filter((id) => id !== itemId));\n            }\n            else {\n                const descendants = getAllLoadedDescendants(tree, itemId);\n                tree.applySubStateUpdate(\"checkedItems\", (items) => items.filter((id) => !descendants.includes(id)));\n            }\n        },\n    },\n};\n", "const specialKeys = {\n    // TODO:breaking deprecate auto-lowercase\n    letter: /^Key[A-Z]$/,\n    letterornumber: /^(Key[A-Z]|Digit[0-9])$/,\n    plus: /^(NumpadAdd|Plus)$/,\n    minus: /^(NumpadSubtract|Minus)$/,\n    control: /^(ControlLeft|ControlRight)$/,\n    shift: /^(ShiftLeft|ShiftRight)$/,\n};\nconst testHotkeyMatch = (pressedKeys, tree, hotkey) => {\n    const supposedKeys = hotkey.hotkey.toLowerCase().split(\"+\"); // TODO:breaking deprecate auto-lowercase\n    const doKeysMatch = supposedKeys.every((key) => {\n        if (key in specialKeys) {\n            return [...pressedKeys].some((pressedKey) => specialKeys[key].test(pressedKey));\n        }\n        const pressedKeysLowerCase = [...pressedKeys] // TODO:breaking deprecate auto-lowercase\n            .map((k) => k.toLowerCase());\n        if (pressedKeysLowerCase.includes(key.toLowerCase())) {\n            return true;\n        }\n        if (pressedKeysLowerCase.includes(`key${key.toLowerCase()}`)) {\n            // TODO:breaking deprecate e.key character matching\n            return true;\n        }\n        return false;\n    });\n    const isEnabled = !hotkey.isEnabled || hotkey.isEnabled(tree);\n    const equalCounts = pressedKeys.size === supposedKeys.length;\n    return doKeysMatch && isEnabled && equalCounts;\n};\nconst findHotkeyMatch = (pressedKeys, tree, config1, config2) => {\n    var _a;\n    return (_a = Object.entries(Object.assign(Object.assign({}, config1), config2)).find(([, hotkey]) => testHotkeyMatch(pressedKeys, tree, hotkey))) === null || _a === void 0 ? void 0 : _a[0];\n};\nexport const hotkeysCoreFeature = {\n    key: \"hotkeys-core\",\n    onTreeMount: (tree, element) => {\n        const data = tree.getDataRef();\n        const keydown = (e) => {\n            var _a;\n            var _b;\n            const { ignoreHotkeysOnInputs, onTreeHotkey, hotkeys } = tree.getConfig();\n            if (e.target instanceof HTMLInputElement && ignoreHotkeysOnInputs) {\n                return;\n            }\n            (_a = (_b = data.current).pressedKeys) !== null && _a !== void 0 ? _a : (_b.pressedKeys = new Set());\n            const newMatch = !data.current.pressedKeys.has(e.code);\n            data.current.pressedKeys.add(e.code);\n            const hotkeyName = findHotkeyMatch(data.current.pressedKeys, tree, tree.getHotkeyPresets(), hotkeys);\n            if (e.target instanceof HTMLInputElement) {\n                // JS respects composite keydowns while input elements are focused, and\n                // doesnt send the associated keyup events with the same key name\n                data.current.pressedKeys.delete(e.code);\n            }\n            if (!hotkeyName)\n                return;\n            const hotkeyConfig = Object.assign(Object.assign({}, tree.getHotkeyPresets()[hotkeyName]), hotkeys === null || hotkeys === void 0 ? void 0 : hotkeys[hotkeyName]);\n            if (!hotkeyConfig)\n                return;\n            if (!hotkeyConfig.allowWhenInputFocused &&\n                e.target instanceof HTMLInputElement)\n                return;\n            if (!hotkeyConfig.canRepeat && !newMatch)\n                return;\n            if (hotkeyConfig.preventDefault)\n                e.preventDefault();\n            hotkeyConfig.handler(e, tree);\n            onTreeHotkey === null || onTreeHotkey === void 0 ? void 0 : onTreeHotkey(hotkeyName, e);\n        };\n        const keyup = (e) => {\n            var _a;\n            var _b;\n            (_a = (_b = data.current).pressedKeys) !== null && _a !== void 0 ? _a : (_b.pressedKeys = new Set());\n            data.current.pressedKeys.delete(e.code);\n        };\n        const reset = () => {\n            data.current.pressedKeys = new Set();\n        };\n        // keyup is registered on document, because some hotkeys shift\n        // the focus away from the tree (i.e. search)\n        // and then we wouldn't get the keyup event anymore\n        element.addEventListener(\"keydown\", keydown);\n        document.addEventListener(\"keyup\", keyup);\n        window.addEventListener(\"focus\", reset);\n        data.current.keydownHandler = keydown;\n        data.current.keyupHandler = keyup;\n        data.current.resetHandler = reset;\n    },\n    onTreeUnmount: (tree, element) => {\n        const data = tree.getDataRef();\n        if (data.current.keyupHandler) {\n            document.removeEventListener(\"keyup\", data.current.keyupHandler);\n            delete data.current.keyupHandler;\n        }\n        if (data.current.keydownHandler) {\n            element.removeEventListener(\"keydown\", data.current.keydownHandler);\n            delete data.current.keydownHandler;\n        }\n        if (data.current.resetHandler) {\n            window.removeEventListener(\"focus\", data.current.resetHandler);\n            delete data.current.resetHandler;\n        }\n    },\n};\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { makeStateUpdater } from \"../../utils\";\nconst getDataRef = (tree) => {\n    var _a, _b;\n    var _c, _d;\n    const dataRef = tree.getDataRef();\n    (_a = (_c = dataRef.current).itemData) !== null && _a !== void 0 ? _a : (_c.itemData = {});\n    (_b = (_d = dataRef.current).childrenIds) !== null && _b !== void 0 ? _b : (_d.childrenIds = {});\n    return dataRef;\n};\nconst loadItemData = (tree, itemId) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    const config = tree.getConfig();\n    const dataRef = getDataRef(tree);\n    const item = yield config.dataLoader.getItem(itemId);\n    dataRef.current.itemData[itemId] = item;\n    (_a = config.onLoadedItem) === null || _a === void 0 ? void 0 : _a.call(config, itemId, item);\n    tree.applySubStateUpdate(\"loadingItemData\", (loadingItemData) => loadingItemData.filter((id) => id !== itemId));\n    return item;\n});\nconst loadChildrenIds = (tree, itemId) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a, _b;\n    const config = tree.getConfig();\n    const dataRef = getDataRef(tree);\n    let childrenIds;\n    if (\"getChildrenWithData\" in config.dataLoader) {\n        const children = yield config.dataLoader.getChildrenWithData(itemId);\n        childrenIds = children.map((c) => c.id);\n        dataRef.current.childrenIds[itemId] = childrenIds;\n        children.forEach(({ id, data }) => {\n            var _a;\n            dataRef.current.itemData[id] = data;\n            (_a = config.onLoadedItem) === null || _a === void 0 ? void 0 : _a.call(config, id, data);\n        });\n        (_a = config.onLoadedChildren) === null || _a === void 0 ? void 0 : _a.call(config, itemId, childrenIds);\n        tree.rebuildTree();\n        tree.applySubStateUpdate(\"loadingItemData\", (loadingItemData) => loadingItemData.filter((id) => !childrenIds.includes(id)));\n    }\n    else {\n        childrenIds = yield config.dataLoader.getChildren(itemId);\n        dataRef.current.childrenIds[itemId] = childrenIds;\n        (_b = config.onLoadedChildren) === null || _b === void 0 ? void 0 : _b.call(config, itemId, childrenIds);\n        tree.rebuildTree();\n    }\n    tree.applySubStateUpdate(\"loadingItemChildrens\", (loadingItemChildrens) => loadingItemChildrens.filter((id) => id !== itemId));\n    return childrenIds;\n});\nexport const asyncDataLoaderFeature = {\n    key: \"async-data-loader\",\n    getInitialState: (initialState) => (Object.assign({ loadingItemData: [], loadingItemChildrens: [] }, initialState)),\n    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setLoadingItemData: makeStateUpdater(\"loadingItemData\", tree), setLoadingItemChildrens: makeStateUpdater(\"loadingItemChildrens\", tree) }, defaultConfig)),\n    stateHandlerNames: {\n        loadingItemData: \"setLoadingItemData\",\n        loadingItemChildrens: \"setLoadingItemChildrens\",\n    },\n    treeInstance: {\n        waitForItemDataLoaded: ({ tree }, itemId) => tree.loadItemData(itemId),\n        waitForItemChildrenLoaded: ({ tree }, itemId) => tree.loadChildrenIds(itemId),\n        loadItemData: (_a, itemId_1) => __awaiter(void 0, [_a, itemId_1], void 0, function* ({ tree }, itemId) {\n            var _b;\n            return ((_b = getDataRef(tree).current.itemData[itemId]) !== null && _b !== void 0 ? _b : (yield loadItemData(tree, itemId)));\n        }),\n        loadChildrenIds: (_a, itemId_1) => __awaiter(void 0, [_a, itemId_1], void 0, function* ({ tree }, itemId) {\n            var _b;\n            return ((_b = getDataRef(tree).current.childrenIds[itemId]) !== null && _b !== void 0 ? _b : (yield loadChildrenIds(tree, itemId)));\n        }),\n        retrieveItemData: ({ tree }, itemId, skipFetch = false) => {\n            var _a, _b;\n            const config = tree.getConfig();\n            const dataRef = getDataRef(tree);\n            if (dataRef.current.itemData[itemId]) {\n                return dataRef.current.itemData[itemId];\n            }\n            if (!tree.getState().loadingItemData.includes(itemId) && !skipFetch) {\n                tree.applySubStateUpdate(\"loadingItemData\", (loadingItemData) => [\n                    ...loadingItemData,\n                    itemId,\n                ]);\n                loadItemData(tree, itemId);\n            }\n            return (_b = (_a = config.createLoadingItemData) === null || _a === void 0 ? void 0 : _a.call(config)) !== null && _b !== void 0 ? _b : null;\n        },\n        retrieveChildrenIds: ({ tree }, itemId, skipFetch = false) => {\n            const dataRef = getDataRef(tree);\n            if (dataRef.current.childrenIds[itemId]) {\n                return dataRef.current.childrenIds[itemId];\n            }\n            if (tree.getState().loadingItemChildrens.includes(itemId) || skipFetch) {\n                return [];\n            }\n            tree.applySubStateUpdate(\"loadingItemChildrens\", (loadingItemChildrens) => [...loadingItemChildrens, itemId]);\n            loadChildrenIds(tree, itemId);\n            return [];\n        },\n    },\n    itemInstance: {\n        isLoading: ({ tree, item }) => tree.getState().loadingItemData.includes(item.getItemMeta().itemId) ||\n            tree.getState().loadingItemChildrens.includes(item.getItemMeta().itemId),\n        invalidateItemData: (_a, optimistic_1) => __awaiter(void 0, [_a, optimistic_1], void 0, function* ({ tree, itemId }, optimistic) {\n            var _b;\n            if (!optimistic) {\n                (_b = getDataRef(tree).current.itemData) === null || _b === void 0 ? true : delete _b[itemId];\n                tree.applySubStateUpdate(\"loadingItemData\", (loadingItemData) => [\n                    ...loadingItemData,\n                    itemId,\n                ]);\n            }\n            yield loadItemData(tree, itemId);\n        }),\n        invalidateChildrenIds: (_a, optimistic_1) => __awaiter(void 0, [_a, optimistic_1], void 0, function* ({ tree, itemId }, optimistic) {\n            var _b;\n            if (!optimistic) {\n                (_b = getDataRef(tree).current.childrenIds) === null || _b === void 0 ? true : delete _b[itemId];\n                tree.applySubStateUpdate(\"loadingItemChildrens\", (loadingItemChildrens) => [...loadingItemChildrens, itemId]);\n            }\n            yield loadChildrenIds(tree, itemId);\n        }),\n        updateCachedChildrenIds: ({ tree, itemId }, childrenIds) => {\n            const dataRef = tree.getDataRef();\n            dataRef.current.childrenIds[itemId] = childrenIds;\n            tree.rebuildTree();\n        },\n    },\n};\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { makeStateUpdater } from \"../../utils\";\nimport { throwError } from \"../../utilities/errors\";\nconst promiseErrorMessage = \"sync dataLoader returned promise\";\nconst unpromise = (data) => {\n    if (!data || (typeof data === \"object\" && \"then\" in data)) {\n        throw throwError(promiseErrorMessage);\n    }\n    return data;\n};\nexport const syncDataLoaderFeature = {\n    key: \"sync-data-loader\",\n    getInitialState: (initialState) => (Object.assign({ loadingItemData: [], loadingItemChildrens: [] }, initialState)),\n    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setLoadingItemData: makeStateUpdater(\"loadingItemData\", tree), setLoadingItemChildrens: makeStateUpdater(\"loadingItemChildrens\", tree) }, defaultConfig)),\n    stateHandlerNames: {\n        loadingItemData: \"setLoadingItemData\",\n        loadingItemChildrens: \"setLoadingItemChildrens\",\n    },\n    treeInstance: {\n        waitForItemDataLoaded: () => __awaiter(void 0, void 0, void 0, function* () { }),\n        waitForItemChildrenLoaded: () => __awaiter(void 0, void 0, void 0, function* () { }),\n        retrieveItemData: ({ tree }, itemId) => {\n            return unpromise(tree.getConfig().dataLoader.getItem(itemId));\n        },\n        retrieveChildrenIds: ({ tree }, itemId) => {\n            const { dataLoader } = tree.getConfig();\n            if (\"getChildren\" in dataLoader) {\n                return unpromise(dataLoader.getChildren(itemId));\n            }\n            return unpromise(dataLoader.getChildrenWithData(itemId)).map((c) => c.data);\n        },\n        loadItemData: ({ tree }, itemId) => tree.retrieveItemData(itemId),\n        loadChildrenIds: ({ tree }, itemId) => tree.retrieveChildrenIds(itemId),\n    },\n    itemInstance: {\n        isLoading: () => false,\n    },\n};\n", "export var ItemDropCategory;\n(function (ItemDropCategory) {\n    ItemDropCategory[ItemDropCategory[\"Item\"] = 0] = \"Item\";\n    ItemDropCategory[ItemDropCategory[\"ExpandedFolder\"] = 1] = \"ExpandedFolder\";\n    ItemDropCategory[ItemDropCategory[\"LastInGroup\"] = 2] = \"LastInGroup\";\n})(ItemDropCategory || (ItemDropCategory = {}));\nvar PlacementType;\n(function (PlacementType) {\n    PlacementType[PlacementType[\"ReorderAbove\"] = 0] = \"ReorderAbove\";\n    PlacementType[PlacementType[\"ReorderBelow\"] = 1] = \"ReorderBelow\";\n    PlacementType[PlacementType[\"MakeChild\"] = 2] = \"MakeChild\";\n    PlacementType[PlacementType[\"Reparent\"] = 3] = \"Reparent\";\n})(PlacementType || (PlacementType = {}));\nexport const isOrderedDragTarget = (dragTarget) => \"childIndex\" in dragTarget;\nexport const canDrop = (dataTransfer, target, tree) => {\n    var _a, _b, _c;\n    const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;\n    const config = tree.getConfig();\n    if (draggedItems && !((_c = (_b = config.canDrop) === null || _b === void 0 ? void 0 : _b.call(config, draggedItems, target)) !== null && _c !== void 0 ? _c : true)) {\n        return false;\n    }\n    if (draggedItems &&\n        draggedItems.some((draggedItem) => target.item.getId() === draggedItem.getId() ||\n            target.item.isDescendentOf(draggedItem.getId()))) {\n        return false;\n    }\n    if (!draggedItems &&\n        dataTransfer &&\n        config.canDropForeignDragObject &&\n        !config.canDropForeignDragObject(dataTransfer, target)) {\n        return false;\n    }\n    return true;\n};\nexport const getItemDropCategory = (item) => {\n    if (item.isExpanded()) {\n        return ItemDropCategory.ExpandedFolder;\n    }\n    const parent = item.getParent();\n    if (parent && item.getIndexInParent() === item.getItemMeta().setSize - 1) {\n        return ItemDropCategory.LastInGroup;\n    }\n    return ItemDropCategory.Item;\n};\nexport const getInsertionIndex = (children, childIndex, draggedItems) => {\n    var _a;\n    const numberOfDragItemsBeforeTarget = (_a = children\n        .slice(0, childIndex)\n        .reduce((counter, child) => child && (draggedItems === null || draggedItems === void 0 ? void 0 : draggedItems.some((i) => i.getId() === child.getId()))\n        ? ++counter\n        : counter, 0)) !== null && _a !== void 0 ? _a : 0;\n    return childIndex - numberOfDragItemsBeforeTarget;\n};\nconst getTargetPlacement = (e, item, tree, canMakeChild) => {\n    var _a, _b, _c, _d, _e;\n    const config = tree.getConfig();\n    if (!config.canReorder) {\n        return canMakeChild\n            ? { type: PlacementType.MakeChild }\n            : { type: PlacementType.ReorderBelow };\n    }\n    const bb = (_a = item.getElement()) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n    const topPercent = bb ? (e.clientY - bb.top) / bb.height : 0.5;\n    const leftPixels = bb ? e.clientX - bb.left : 0;\n    const targetDropCategory = getItemDropCategory(item);\n    const reorderAreaPercentage = !canMakeChild\n        ? 0.5\n        : (_b = config.reorderAreaPercentage) !== null && _b !== void 0 ? _b : 0.3;\n    const indent = (_c = config.indent) !== null && _c !== void 0 ? _c : 20;\n    const makeChildType = canMakeChild\n        ? PlacementType.MakeChild\n        : PlacementType.ReorderBelow;\n    if (targetDropCategory === ItemDropCategory.ExpandedFolder) {\n        if (topPercent < reorderAreaPercentage) {\n            return { type: PlacementType.ReorderAbove };\n        }\n        return { type: makeChildType };\n    }\n    if (targetDropCategory === ItemDropCategory.LastInGroup) {\n        if (leftPixels < item.getItemMeta().level * indent) {\n            if (topPercent < 0.5) {\n                return { type: PlacementType.ReorderAbove };\n            }\n            const minLevel = (_e = (_d = item.getItemBelow()) === null || _d === void 0 ? void 0 : _d.getItemMeta().level) !== null && _e !== void 0 ? _e : 0;\n            return {\n                type: PlacementType.Reparent,\n                reparentLevel: Math.max(minLevel, Math.floor(leftPixels / indent)),\n            };\n        }\n        // if not at left of item area, treat as if it was a normal item\n    }\n    // targetDropCategory === ItemDropCategory.Item\n    if (topPercent < reorderAreaPercentage) {\n        return { type: PlacementType.ReorderAbove };\n    }\n    if (topPercent > 1 - reorderAreaPercentage) {\n        return { type: PlacementType.ReorderBelow };\n    }\n    return { type: makeChildType };\n};\nexport const getDragCode = (e, item, tree) => {\n    const placement = getTargetPlacement(e, item, tree, true);\n    return [\n        item.getId(),\n        placement.type,\n        placement.type === PlacementType.Reparent ? placement.reparentLevel : 0,\n    ].join(\"__\");\n};\nconst getNthParent = (item, n) => {\n    if (n === item.getItemMeta().level) {\n        return item;\n    }\n    return getNthParent(item.getParent(), n);\n};\n/** @param item refers to the bottom-most item of the container, at which bottom is being reparented on (e.g. root-1-2-6)  */\nexport const getReparentTarget = (item, reparentLevel, draggedItems) => {\n    const itemMeta = item.getItemMeta();\n    const reparentedTarget = getNthParent(item, reparentLevel - 1);\n    const targetItemAbove = getNthParent(item, reparentLevel); // .getItemBelow()!;\n    const targetIndex = targetItemAbove.getIndexInParent() + 1;\n    return {\n        item: reparentedTarget,\n        childIndex: targetIndex,\n        insertionIndex: getInsertionIndex(reparentedTarget.getChildren(), targetIndex, draggedItems),\n        dragLineIndex: itemMeta.index + 1,\n        dragLineLevel: reparentLevel,\n    };\n};\nexport const getDragTarget = (e, item, tree, canReorder = tree.getConfig().canReorder) => {\n    var _a;\n    const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;\n    const itemMeta = item.getItemMeta();\n    const parent = item.getParent();\n    const itemTarget = { item };\n    const parentTarget = parent ? { item: parent } : null;\n    const canBecomeSibling = parentTarget && canDrop(e.dataTransfer, parentTarget, tree);\n    const canMakeChild = canDrop(e.dataTransfer, itemTarget, tree);\n    const placement = getTargetPlacement(e, item, tree, canMakeChild);\n    if (!canReorder &&\n        parent &&\n        canBecomeSibling &&\n        placement.type !== PlacementType.MakeChild) {\n        return parentTarget;\n    }\n    if (!canReorder && parent && !canBecomeSibling) {\n        // TODO! this breaks in story DND/Can Drop. Maybe move this logic into a composable DragTargetStrategy[] ?\n        return getDragTarget(e, parent, tree, false);\n    }\n    if (!parent) {\n        // Shouldn't happen, but if dropped \"next\" to root item, just drop it inside\n        return itemTarget;\n    }\n    if (placement.type === PlacementType.MakeChild) {\n        return itemTarget;\n    }\n    if (!canBecomeSibling) {\n        return getDragTarget(e, parent, tree, false);\n    }\n    if (placement.type === PlacementType.Reparent) {\n        return getReparentTarget(item, placement.reparentLevel, draggedItems);\n    }\n    const maybeAddOneForBelow = placement.type === PlacementType.ReorderAbove ? 0 : 1;\n    const childIndex = item.getIndexInParent() + maybeAddOneForBelow;\n    return {\n        item: parent,\n        dragLineIndex: itemMeta.index + maybeAddOneForBelow,\n        dragLineLevel: itemMeta.level,\n        childIndex,\n        // TODO performance could be improved by computing this only when dragcode changed\n        insertionIndex: getInsertionIndex(parent.getChildren(), childIndex, draggedItems),\n    };\n};\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { canDrop, getDragCode, getDragTarget, isOrderedDragTarget, } from \"./utils\";\nimport { makeStateUpdater } from \"../../utils\";\nexport const dragAndDropFeature = {\n    key: \"drag-and-drop\",\n    deps: [\"selection\"],\n    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ canDrop: (_, target) => target.item.isFolder(), canDropForeignDragObject: () => false, setDndState: makeStateUpdater(\"dnd\", tree), canReorder: true }, defaultConfig)),\n    stateHandlerNames: {\n        dnd: \"setDndState\",\n    },\n    treeInstance: {\n        getDragTarget: ({ tree }) => {\n            var _a, _b;\n            return (_b = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.dragTarget) !== null && _b !== void 0 ? _b : null;\n        },\n        getDragLineData: ({ tree }) => {\n            var _a, _b, _c, _d, _e, _f;\n            const target = tree.getDragTarget();\n            const indent = ((_a = target === null || target === void 0 ? void 0 : target.item.getItemMeta().level) !== null && _a !== void 0 ? _a : 0) + 1;\n            const treeBb = (_b = tree.getElement()) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();\n            if (!target || !treeBb || !isOrderedDragTarget(target))\n                return null;\n            const leftOffset = target.dragLineLevel * ((_c = tree.getConfig().indent) !== null && _c !== void 0 ? _c : 1);\n            const targetItem = tree.getItems()[target.dragLineIndex];\n            if (!targetItem) {\n                const bb = (_e = (_d = tree\n                    .getItems()[target.dragLineIndex - 1]) === null || _d === void 0 ? void 0 : _d.getElement()) === null || _e === void 0 ? void 0 : _e.getBoundingClientRect();\n                if (bb) {\n                    return {\n                        indent,\n                        top: bb.bottom - treeBb.top,\n                        left: bb.left + leftOffset - treeBb.left,\n                        width: bb.width - leftOffset,\n                    };\n                }\n            }\n            const bb = (_f = targetItem.getElement()) === null || _f === void 0 ? void 0 : _f.getBoundingClientRect();\n            if (bb) {\n                return {\n                    indent,\n                    top: bb.top - treeBb.top,\n                    left: bb.left + leftOffset - treeBb.left,\n                    width: bb.width - leftOffset,\n                };\n            }\n            return null;\n        },\n        getDragLineStyle: ({ tree }, topOffset = -1, leftOffset = -8) => {\n            const dragLine = tree.getDragLineData();\n            return dragLine\n                ? {\n                    position: \"absolute\",\n                    top: `${dragLine.top + topOffset}px`,\n                    left: `${dragLine.left + leftOffset}px`,\n                    width: `${dragLine.width - leftOffset}px`,\n                    pointerEvents: \"none\", // important to prevent capturing drag events\n                }\n                : { display: \"none\" };\n        },\n        getContainerProps: ({ prev, tree }, treeLabel) => {\n            const prevProps = prev === null || prev === void 0 ? void 0 : prev(treeLabel);\n            return Object.assign(Object.assign({}, prevProps), { onDragOver: (e) => {\n                    e.preventDefault();\n                }, onDrop: (e) => __awaiter(void 0, void 0, void 0, function* () {\n                    var _a, _b, _c;\n                    // TODO merge implementation with itemInstance.onDrop\n                    const dataRef = tree.getDataRef();\n                    const target = { item: tree.getRootItem() };\n                    if (!canDrop(e.dataTransfer, target, tree)) {\n                        return;\n                    }\n                    e.preventDefault();\n                    const config = tree.getConfig();\n                    const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;\n                    dataRef.current.lastDragCode = undefined;\n                    tree.applySubStateUpdate(\"dnd\", null);\n                    if (draggedItems) {\n                        yield ((_b = config.onDrop) === null || _b === void 0 ? void 0 : _b.call(config, draggedItems, target));\n                    }\n                    else if (e.dataTransfer) {\n                        yield ((_c = config.onDropForeignDragObject) === null || _c === void 0 ? void 0 : _c.call(config, e.dataTransfer, target));\n                    }\n                }), style: Object.assign(Object.assign({}, prevProps === null || prevProps === void 0 ? void 0 : prevProps.style), { position: \"relative\" }) });\n        },\n    },\n    itemInstance: {\n        getProps: ({ tree, item, prev }) => (Object.assign(Object.assign({}, prev === null || prev === void 0 ? void 0 : prev()), { draggable: true, onDragEnter: (e) => e.preventDefault(), onDragStart: (e) => {\n                var _a, _b, _c, _d;\n                const selectedItems = tree.getSelectedItems();\n                const items = selectedItems.includes(item) ? selectedItems : [item];\n                const config = tree.getConfig();\n                if (!selectedItems.includes(item)) {\n                    tree.setSelectedItems([item.getItemMeta().itemId]);\n                }\n                if (!((_b = (_a = config.canDrag) === null || _a === void 0 ? void 0 : _a.call(config, items)) !== null && _b !== void 0 ? _b : true)) {\n                    e.preventDefault();\n                    return;\n                }\n                if (config.setDragImage) {\n                    const { imgElement, xOffset, yOffset } = config.setDragImage(items);\n                    (_c = e.dataTransfer) === null || _c === void 0 ? void 0 : _c.setDragImage(imgElement, xOffset !== null && xOffset !== void 0 ? xOffset : 0, yOffset !== null && yOffset !== void 0 ? yOffset : 0);\n                }\n                if (config.createForeignDragObject) {\n                    const { format, data } = config.createForeignDragObject(items);\n                    (_d = e.dataTransfer) === null || _d === void 0 ? void 0 : _d.setData(format, data);\n                }\n                tree.applySubStateUpdate(\"dnd\", {\n                    draggedItems: items,\n                    draggingOverItem: tree.getFocusedItem(),\n                });\n            }, onDragOver: (e) => {\n                var _a, _b, _c;\n                const dataRef = tree.getDataRef();\n                const nextDragCode = getDragCode(e, item, tree);\n                if (nextDragCode === dataRef.current.lastDragCode) {\n                    if (dataRef.current.lastAllowDrop) {\n                        e.preventDefault();\n                    }\n                    return;\n                }\n                dataRef.current.lastDragCode = nextDragCode;\n                const target = getDragTarget(e, item, tree);\n                if (!((_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems) &&\n                    (!e.dataTransfer ||\n                        !((_c = (_b = tree\n                            .getConfig()).canDropForeignDragObject) === null || _c === void 0 ? void 0 : _c.call(_b, e.dataTransfer, target)))) {\n                    dataRef.current.lastAllowDrop = false;\n                    return;\n                }\n                if (!canDrop(e.dataTransfer, target, tree)) {\n                    dataRef.current.lastAllowDrop = false;\n                    return;\n                }\n                tree.applySubStateUpdate(\"dnd\", (state) => (Object.assign(Object.assign({}, state), { dragTarget: target, draggingOverItem: item })));\n                dataRef.current.lastAllowDrop = true;\n                e.preventDefault();\n            }, onDragLeave: () => {\n                const dataRef = tree.getDataRef();\n                dataRef.current.lastDragCode = \"no-drag\";\n                tree.applySubStateUpdate(\"dnd\", (state) => (Object.assign(Object.assign({}, state), { draggingOverItem: undefined, dragTarget: undefined })));\n            }, onDragEnd: (e) => {\n                var _a, _b, _c, _d;\n                const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;\n                tree.applySubStateUpdate(\"dnd\", null);\n                if (((_b = e.dataTransfer) === null || _b === void 0 ? void 0 : _b.dropEffect) === \"none\" || !draggedItems) {\n                    return;\n                }\n                (_d = (_c = tree.getConfig()).onCompleteForeignDrop) === null || _d === void 0 ? void 0 : _d.call(_c, draggedItems);\n            }, onDrop: (e) => __awaiter(void 0, void 0, void 0, function* () {\n                var _a, _b, _c;\n                e.stopPropagation();\n                const dataRef = tree.getDataRef();\n                const target = getDragTarget(e, item, tree);\n                if (!canDrop(e.dataTransfer, target, tree)) {\n                    return;\n                }\n                e.preventDefault();\n                const config = tree.getConfig();\n                const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;\n                dataRef.current.lastDragCode = undefined;\n                tree.applySubStateUpdate(\"dnd\", null);\n                if (draggedItems) {\n                    yield ((_b = config.onDrop) === null || _b === void 0 ? void 0 : _b.call(config, draggedItems, target));\n                }\n                else if (e.dataTransfer) {\n                    yield ((_c = config.onDropForeignDragObject) === null || _c === void 0 ? void 0 : _c.call(config, e.dataTransfer, target));\n                }\n            }) })),\n        isDragTarget: ({ tree, item }) => {\n            const target = tree.getDragTarget();\n            return target ? target.item.getId() === item.getId() : false;\n        },\n        isDragTargetAbove: ({ tree, item }) => {\n            const target = tree.getDragTarget();\n            if (!target ||\n                !isOrderedDragTarget(target) ||\n                target.item !== item.getParent())\n                return false;\n            return target.childIndex === item.getItemMeta().posInSet;\n        },\n        isDragTargetBelow: ({ tree, item }) => {\n            const target = tree.getDragTarget();\n            if (!target ||\n                !isOrderedDragTarget(target) ||\n                target.item !== item.getParent())\n                return false;\n            return target.childIndex - 1 === item.getItemMeta().posInSet;\n        },\n        isDraggingOver: ({ tree, item }) => {\n            var _a, _b;\n            return ((_b = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggingOverItem) === null || _b === void 0 ? void 0 : _b.getId()) === item.getId();\n        },\n    },\n};\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ItemDropCategory, canDrop, getInsertionIndex, getItemDropCategory, getReparentTarget, isOrderedDragTarget, } from \"../drag-and-drop/utils\";\nimport { makeStateUpdater } from \"../../utils\";\nimport { AssistiveDndState } from \"./types\";\nconst getNextDragTarget = (tree, isUp, dragTarget) => {\n    var _a, _b, _c, _d;\n    const direction = isUp ? 0 : 1;\n    const draggedItems = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems;\n    // currently hovering between items\n    if (isOrderedDragTarget(dragTarget)) {\n        const parent = dragTarget.item.getParent();\n        const targetedItem = tree.getItems()[dragTarget.dragLineIndex - 1]; // item above dragline\n        const targetCategory = targetedItem\n            ? getItemDropCategory(targetedItem)\n            : ItemDropCategory.Item;\n        const maxLevel = (_b = targetedItem === null || targetedItem === void 0 ? void 0 : targetedItem.getItemMeta().level) !== null && _b !== void 0 ? _b : 0;\n        const minLevel = (_d = (_c = targetedItem === null || targetedItem === void 0 ? void 0 : targetedItem.getItemBelow()) === null || _c === void 0 ? void 0 : _c.getItemMeta().level) !== null && _d !== void 0 ? _d : 0;\n        // reparenting\n        if (targetCategory === ItemDropCategory.LastInGroup) {\n            if (isUp && dragTarget.dragLineLevel < maxLevel) {\n                return getReparentTarget(targetedItem, dragTarget.dragLineLevel + 1, draggedItems);\n            }\n            if (!isUp && dragTarget.dragLineLevel > minLevel && parent) {\n                return getReparentTarget(targetedItem, dragTarget.dragLineLevel - 1, draggedItems);\n            }\n        }\n        const newIndex = dragTarget.dragLineIndex - 1 + direction;\n        const item = tree.getItems()[newIndex];\n        return item ? { item } : undefined;\n    }\n    // moving upwards outside of an open folder\n    const targetingExpandedFolder = getItemDropCategory(dragTarget.item) === ItemDropCategory.ExpandedFolder;\n    if (targetingExpandedFolder && !isUp) {\n        return {\n            item: dragTarget.item,\n            childIndex: 0,\n            insertionIndex: getInsertionIndex(dragTarget.item.getChildren(), 0, draggedItems),\n            dragLineIndex: dragTarget.item.getItemMeta().index + direction,\n            dragLineLevel: dragTarget.item.getItemMeta().level + 1,\n        };\n    }\n    // currently hovering over item\n    const childIndex = dragTarget.item.getIndexInParent() + direction;\n    return {\n        item: dragTarget.item.getParent(),\n        childIndex,\n        insertionIndex: getInsertionIndex(dragTarget.item.getParent().getChildren(), childIndex, draggedItems),\n        dragLineIndex: dragTarget.item.getItemMeta().index + direction,\n        dragLineLevel: dragTarget.item.getItemMeta().level,\n    };\n};\nconst getNextValidDragTarget = (tree, isUp, previousTarget) => {\n    var _a, _b;\n    if (previousTarget === void 0) { previousTarget = (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.dragTarget; }\n    if (!previousTarget)\n        return undefined;\n    const nextTarget = getNextDragTarget(tree, isUp, previousTarget);\n    const dataTransfer = (_b = tree.getDataRef().current.kDndDataTransfer) !== null && _b !== void 0 ? _b : null;\n    if (!nextTarget)\n        return undefined;\n    if (canDrop(dataTransfer, nextTarget, tree)) {\n        return nextTarget;\n    }\n    return getNextValidDragTarget(tree, isUp, nextTarget);\n};\nconst updateScroll = (tree) => {\n    const state = tree.getState().dnd;\n    if (!(state === null || state === void 0 ? void 0 : state.dragTarget) || isOrderedDragTarget(state.dragTarget))\n        return;\n    state.dragTarget.item.scrollTo({ block: \"nearest\", inline: \"nearest\" });\n};\nconst initiateDrag = (tree, draggedItems, dataTransfer) => {\n    var _a, _b;\n    const focusedItem = tree.getFocusedItem();\n    const { canDrag } = tree.getConfig();\n    if (draggedItems && canDrag && !canDrag(draggedItems)) {\n        return;\n    }\n    if (draggedItems) {\n        tree.applySubStateUpdate(\"dnd\", { draggedItems });\n        // getNextValidDragTarget->canDrop needs the draggedItems in state\n        (_b = (_a = tree.getConfig()).onStartKeyboardDrag) === null || _b === void 0 ? void 0 : _b.call(_a, draggedItems);\n    }\n    else if (dataTransfer) {\n        tree.getDataRef().current.kDndDataTransfer = dataTransfer;\n    }\n    const dragTarget = getNextValidDragTarget(tree, false, {\n        item: focusedItem,\n    });\n    if (!dragTarget)\n        return;\n    tree.applySubStateUpdate(\"dnd\", {\n        draggedItems,\n        dragTarget,\n    });\n    tree.applySubStateUpdate(\"assistiveDndState\", AssistiveDndState.Started);\n    updateScroll(tree);\n};\nconst moveDragPosition = (tree, isUp) => {\n    var _a;\n    const dragTarget = getNextValidDragTarget(tree, isUp);\n    if (!dragTarget)\n        return;\n    tree.applySubStateUpdate(\"dnd\", {\n        draggedItems: (_a = tree.getState().dnd) === null || _a === void 0 ? void 0 : _a.draggedItems,\n        dragTarget,\n    });\n    tree.applySubStateUpdate(\"assistiveDndState\", AssistiveDndState.Dragging);\n    if (!isOrderedDragTarget(dragTarget)) {\n        dragTarget.item.setFocused();\n    }\n    updateScroll(tree);\n};\nexport const keyboardDragAndDropFeature = {\n    key: \"keyboard-drag-and-drop\",\n    deps: [\"drag-and-drop\"],\n    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setAssistiveDndState: makeStateUpdater(\"assistiveDndState\", tree) }, defaultConfig)),\n    stateHandlerNames: {\n        assistiveDndState: \"setAssistiveDndState\",\n    },\n    treeInstance: {\n        startKeyboardDrag: ({ tree }, draggedItems) => {\n            initiateDrag(tree, draggedItems, undefined);\n        },\n        startKeyboardDragOnForeignObject: ({ tree }, dataTransfer) => {\n            initiateDrag(tree, undefined, dataTransfer);\n        },\n        stopKeyboardDrag: ({ tree }) => {\n            tree.getDataRef().current.kDndDataTransfer = undefined;\n            tree.applySubStateUpdate(\"dnd\", null);\n            tree.applySubStateUpdate(\"assistiveDndState\", AssistiveDndState.None);\n        },\n    },\n    hotkeys: {\n        startDrag: {\n            hotkey: \"Control+Shift+KeyD\",\n            preventDefault: true,\n            isEnabled: (tree) => !tree.getState().dnd,\n            handler: (_, tree) => {\n                tree.startKeyboardDrag(tree.getSelectedItems());\n            },\n        },\n        dragUp: {\n            hotkey: \"ArrowUp\",\n            preventDefault: true,\n            isEnabled: (tree) => !!tree.getState().dnd,\n            handler: (_, tree) => {\n                moveDragPosition(tree, true);\n            },\n        },\n        dragDown: {\n            hotkey: \"ArrowDown\",\n            preventDefault: true,\n            isEnabled: (tree) => !!tree.getState().dnd,\n            handler: (_, tree) => {\n                moveDragPosition(tree, false);\n            },\n        },\n        cancelDrag: {\n            hotkey: \"Escape\",\n            isEnabled: (tree) => !!tree.getState().dnd,\n            handler: (_, tree) => {\n                tree.stopKeyboardDrag();\n            },\n        },\n        completeDrag: {\n            hotkey: \"Enter\",\n            preventDefault: true,\n            isEnabled: (tree) => !!tree.getState().dnd,\n            handler: (e, tree) => __awaiter(void 0, void 0, void 0, function* () {\n                var _a, _b, _c, _d;\n                e.stopPropagation();\n                // TODO copied from keyboard onDrop, unify them\n                const dataRef = tree.getDataRef();\n                const target = tree.getDragTarget();\n                const dataTransfer = (_a = dataRef.current.kDndDataTransfer) !== null && _a !== void 0 ? _a : null;\n                if (!target || !canDrop(dataTransfer, target, tree)) {\n                    return;\n                }\n                const config = tree.getConfig();\n                const draggedItems = (_b = tree.getState().dnd) === null || _b === void 0 ? void 0 : _b.draggedItems;\n                dataRef.current.lastDragCode = undefined;\n                tree.applySubStateUpdate(\"dnd\", null);\n                if (draggedItems) {\n                    yield ((_c = config.onDrop) === null || _c === void 0 ? void 0 : _c.call(config, draggedItems, target));\n                    tree.getItemInstance(draggedItems[0].getId()).setFocused();\n                }\n                else if (dataTransfer) {\n                    yield ((_d = config.onDropForeignDragObject) === null || _d === void 0 ? void 0 : _d.call(config, dataTransfer, target));\n                }\n                tree.applySubStateUpdate(\"assistiveDndState\", AssistiveDndState.Completed);\n            }),\n        },\n    },\n};\n", "import { makeStateUpdater, memo } from \"../../utils\";\nexport const searchFeature = {\n    key: \"search\",\n    getInitialState: (initialState) => (Object.assign({ search: null }, initialState)),\n    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setSearch: makeStateUpdater(\"search\", tree), isSearchMatchingItem: (search, item) => search.length > 0 &&\n            item.getItemName().toLowerCase().includes(search.toLowerCase()) }, defaultConfig)),\n    stateHandlerNames: {\n        search: \"setSearch\",\n    },\n    treeInstance: {\n        setSearch: ({ tree }, search) => {\n            var _a;\n            tree.applySubStateUpdate(\"search\", search);\n            (_a = tree\n                .getItems()\n                .find((item) => { var _a, _b; return (_b = (_a = tree.getConfig()).isSearchMatchingItem) === null || _b === void 0 ? void 0 : _b.call(_a, tree.getSearchValue(), item); })) === null || _a === void 0 ? void 0 : _a.setFocused();\n        },\n        openSearch: ({ tree }, initialValue = \"\") => {\n            var _a, _b;\n            tree.setSearch(initialValue);\n            (_b = (_a = tree.getConfig()).onOpenSearch) === null || _b === void 0 ? void 0 : _b.call(_a);\n            setTimeout(() => {\n                var _a;\n                (_a = tree.getDataRef().current.searchInput) === null || _a === void 0 ? void 0 : _a.focus();\n            });\n        },\n        closeSearch: ({ tree }) => {\n            var _a, _b;\n            tree.setSearch(null);\n            (_b = (_a = tree.getConfig()).onCloseSearch) === null || _b === void 0 ? void 0 : _b.call(_a);\n            tree.updateDomFocus();\n        },\n        isSearchOpen: ({ tree }) => tree.getState().search !== null,\n        getSearchValue: ({ tree }) => tree.getState().search || \"\",\n        registerSearchInputElement: ({ tree }, element) => {\n            const dataRef = tree.getDataRef();\n            dataRef.current.searchInput = element;\n            if (element && dataRef.current.keydownHandler) {\n                element.addEventListener(\"keydown\", dataRef.current.keydownHandler);\n            }\n        },\n        getSearchInputElement: ({ tree }) => { var _a; return (_a = tree.getDataRef().current.searchInput) !== null && _a !== void 0 ? _a : null; },\n        // TODO memoize with propMemoizationFeature\n        getSearchInputElementProps: ({ tree }) => ({\n            value: tree.getSearchValue(),\n            onChange: (e) => tree.setSearch(e.target.value),\n            onBlur: () => tree.closeSearch(),\n            ref: tree.registerSearchInputElement,\n        }),\n        getSearchMatchingItems: memo(({ tree }) => [\n            tree.getSearchValue(),\n            tree.getItems(),\n            tree.getConfig().isSearchMatchingItem,\n        ], (search, items, isSearchMatchingItem) => items.filter((item) => search && (isSearchMatchingItem === null || isSearchMatchingItem === void 0 ? void 0 : isSearchMatchingItem(search, item)))),\n    },\n    itemInstance: {\n        isMatchingSearch: ({ tree, item }) => tree.getSearchMatchingItems().some((i) => i.getId() === item.getId()),\n    },\n    hotkeys: {\n        openSearch: {\n            hotkey: \"LetterOrNumber\",\n            preventDefault: true, // TODO make true default\n            isEnabled: (tree) => !tree.isSearchOpen(),\n            handler: (e, tree) => {\n                e.stopPropagation();\n                tree.openSearch(e.key);\n            },\n        },\n        closeSearch: {\n            // TODO allow multiple, i.e. Enter\n            hotkey: \"Escape\",\n            allowWhenInputFocused: true,\n            isEnabled: (tree) => tree.isSearchOpen(),\n            handler: (e, tree) => {\n                tree.closeSearch();\n            },\n        },\n        submitSearch: {\n            hotkey: \"Enter\",\n            allowWhenInputFocused: true,\n            isEnabled: (tree) => tree.isSearchOpen(),\n            handler: (e, tree) => {\n                tree.closeSearch();\n                tree.setSelectedItems([tree.getFocusedItem().getId()]);\n            },\n        },\n        nextSearchItem: {\n            hotkey: \"ArrowDown\",\n            allowWhenInputFocused: true,\n            canRepeat: true,\n            isEnabled: (tree) => tree.isSearchOpen(),\n            handler: (e, tree) => {\n                const focusItem = tree\n                    .getSearchMatchingItems()\n                    .find((item) => item.getItemMeta().index >\n                    tree.getFocusedItem().getItemMeta().index);\n                focusItem === null || focusItem === void 0 ? void 0 : focusItem.setFocused();\n                focusItem === null || focusItem === void 0 ? void 0 : focusItem.scrollTo({ block: \"nearest\", inline: \"nearest\" });\n            },\n        },\n        previousSearchItem: {\n            hotkey: \"ArrowUp\",\n            allowWhenInputFocused: true,\n            canRepeat: true,\n            isEnabled: (tree) => tree.isSearchOpen(),\n            handler: (e, tree) => {\n                const focusItem = [...tree.getSearchMatchingItems()]\n                    .reverse()\n                    .find((item) => item.getItemMeta().index <\n                    tree.getFocusedItem().getItemMeta().index);\n                focusItem === null || focusItem === void 0 ? void 0 : focusItem.setFocused();\n                focusItem === null || focusItem === void 0 ? void 0 : focusItem.scrollTo({ block: \"nearest\", inline: \"nearest\" });\n            },\n        },\n    },\n};\n", "import { makeStateUpdater } from \"../../utils\";\nexport const renamingFeature = {\n    key: \"renaming\",\n    overwrites: [\"drag-and-drop\"],\n    getDefaultConfig: (defaultConfig, tree) => (Object.assign({ setRenamingItem: makeStateUpdater(\"renamingItem\", tree), setRenamingValue: makeStateUpdater(\"renamingValue\", tree), canRename: () => true }, defaultConfig)),\n    stateHandlerNames: {\n        renamingItem: \"setRenamingItem\",\n        renamingValue: \"setRenamingValue\",\n    },\n    treeInstance: {\n        getRenamingItem: ({ tree }) => {\n            const itemId = tree.getState().renamingItem;\n            return itemId ? tree.getItemInstance(itemId) : null;\n        },\n        getRenamingValue: ({ tree }) => tree.getState().renamingValue || \"\",\n        abortRenaming: ({ tree }) => {\n            tree.applySubStateUpdate(\"renamingItem\", null);\n            tree.updateDomFocus();\n        },\n        completeRenaming: ({ tree }) => {\n            var _a;\n            const config = tree.getConfig();\n            const item = tree.getRenamingItem();\n            if (item) {\n                (_a = config.onRename) === null || _a === void 0 ? void 0 : _a.call(config, item, tree.getState().renamingValue || \"\");\n            }\n            tree.applySubStateUpdate(\"renamingItem\", null);\n            tree.updateDomFocus();\n        },\n        isRenamingItem: ({ tree }) => !!tree.getState().renamingItem,\n    },\n    itemInstance: {\n        startRenaming: ({ tree, item, itemId }) => {\n            if (!item.canRename()) {\n                return;\n            }\n            tree.applySubStateUpdate(\"renamingItem\", itemId);\n            tree.applySubStateUpdate(\"renamingValue\", item.getItemName());\n        },\n        getRenameInputProps: ({ tree }) => ({\n            ref: (r) => r === null || r === void 0 ? void 0 : r.focus(),\n            onBlur: () => tree.abortRenaming(),\n            value: tree.getRenamingValue(),\n            onChange: (e) => {\n                var _a;\n                tree.applySubStateUpdate(\"renamingValue\", (_a = e.target) === null || _a === void 0 ? void 0 : _a.value);\n            },\n        }),\n        canRename: ({ tree, item }) => { var _a, _b, _c; return (_c = (_b = (_a = tree.getConfig()).canRename) === null || _b === void 0 ? void 0 : _b.call(_a, item)) !== null && _c !== void 0 ? _c : true; },\n        isRenaming: ({ tree, item }) => item.getId() === tree.getState().renamingItem,\n        getProps: ({ prev, item }) => {\n            var _a;\n            const isRenaming = item.isRenaming();\n            const prevProps = (_a = prev === null || prev === void 0 ? void 0 : prev()) !== null && _a !== void 0 ? _a : {};\n            return isRenaming\n                ? Object.assign(Object.assign({}, prevProps), { draggable: false, onDragStart: () => { } }) : prevProps;\n        },\n    },\n    hotkeys: {\n        renameItem: {\n            hotkey: \"F2\",\n            handler: (e, tree) => {\n                tree.getFocusedItem().startRenaming();\n            },\n        },\n        abortRenaming: {\n            hotkey: \"Escape\",\n            allowWhenInputFocused: true,\n            isEnabled: (tree) => tree.isRenamingItem(),\n            handler: (e, tree) => {\n                tree.abortRenaming();\n            },\n        },\n        completeRenaming: {\n            hotkey: \"Enter\",\n            allowWhenInputFocused: true,\n            isEnabled: (tree) => tree.isRenamingItem(),\n            handler: (e, tree) => {\n                tree.completeRenaming();\n            },\n        },\n    },\n};\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const expandAllFeature = {\n    key: \"expand-all\",\n    treeInstance: {\n        expandAll: (_a, cancelToken_1) => __awaiter(void 0, [_a, cancelToken_1], void 0, function* ({ tree }, cancelToken) {\n            yield Promise.all(tree.getItems().map((item) => item.expandAll(cancelToken)));\n        }),\n        collapseAll: ({ tree }) => {\n            tree.applySubStateUpdate(\"expandedItems\", []);\n            tree.rebuildTree();\n        },\n    },\n    itemInstance: {\n        expandAll: (_a, cancelToken_1) => __awaiter(void 0, [_a, cancelToken_1], void 0, function* ({ tree, item }, cancelToken) {\n            if (cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.current) {\n                return;\n            }\n            if (!item.isFolder()) {\n                return;\n            }\n            item.expand();\n            yield tree.waitForItemChildrenLoaded(item.getId());\n            yield Promise.all(item.getChildren().map((child) => __awaiter(void 0, void 0, void 0, function* () {\n                yield tree.waitForItemChildrenLoaded(item.getId());\n                yield (child === null || child === void 0 ? void 0 : child.expandAll(cancelToken));\n            })));\n        }),\n        collapseAll: ({ item }) => {\n            if (!item.isExpanded())\n                return;\n            for (const child of item.getChildren()) {\n                child === null || child === void 0 ? void 0 : child.collapseAll();\n            }\n            item.collapse();\n        },\n    },\n    hotkeys: {\n        expandSelected: {\n            hotkey: \"Control+Shift+Plus\",\n            handler: (_, tree) => __awaiter(void 0, void 0, void 0, function* () {\n                const cancelToken = { current: false };\n                const cancelHandler = (e) => {\n                    if (e.code === \"Escape\") {\n                        cancelToken.current = true;\n                    }\n                };\n                document.addEventListener(\"keydown\", cancelHandler);\n                yield Promise.all(tree.getSelectedItems().map((item) => item.expandAll(cancelToken)));\n                document.removeEventListener(\"keydown\", cancelHandler);\n            }),\n        },\n        collapseSelected: {\n            hotkey: \"Control+Shift+Minus\",\n            handler: (_, tree) => {\n                tree.getSelectedItems().forEach((item) => item.collapseAll());\n            },\n        },\n    },\n};\n", "const memoize = (props, memoizedProps) => {\n    for (const key in props) {\n        if (typeof props[key] === \"function\") {\n            if (memoizedProps && key in memoizedProps) {\n                props[key] = memoizedProps[key];\n            }\n            else {\n                memoizedProps[key] = props[key];\n            }\n        }\n    }\n    return props;\n};\nexport const propMemoizationFeature = {\n    key: \"prop-memoization\",\n    overwrites: [\n        \"main\",\n        \"async-data-loader\",\n        \"sync-data-loader\",\n        \"drag-and-drop\",\n        \"expand-all\",\n        \"hotkeys-core\",\n        \"renaming\",\n        \"search\",\n        \"selection\",\n    ],\n    treeInstance: {\n        getContainerProps: ({ tree, prev }, treeLabel) => {\n            var _a, _b, _c;\n            var _d, _e;\n            const dataRef = tree.getDataRef();\n            const props = (_a = prev === null || prev === void 0 ? void 0 : prev(treeLabel)) !== null && _a !== void 0 ? _a : {};\n            (_b = (_d = dataRef.current).memo) !== null && _b !== void 0 ? _b : (_d.memo = {});\n            (_c = (_e = dataRef.current.memo).tree) !== null && _c !== void 0 ? _c : (_e.tree = {});\n            return memoize(props, dataRef.current.memo.tree);\n        },\n        getSearchInputElementProps: ({ tree, prev }) => {\n            var _a, _b, _c;\n            var _d, _e;\n            const dataRef = tree.getDataRef();\n            const props = (_a = prev === null || prev === void 0 ? void 0 : prev()) !== null && _a !== void 0 ? _a : {};\n            (_b = (_d = dataRef.current).memo) !== null && _b !== void 0 ? _b : (_d.memo = {});\n            (_c = (_e = dataRef.current.memo).search) !== null && _c !== void 0 ? _c : (_e.search = {});\n            return memoize(props, dataRef.current.memo.search);\n        },\n    },\n    itemInstance: {\n        getProps: ({ item, prev }) => {\n            var _a, _b, _c;\n            var _d, _e;\n            const dataRef = item.getDataRef();\n            const props = (_a = prev === null || prev === void 0 ? void 0 : prev()) !== null && _a !== void 0 ? _a : {};\n            (_b = (_d = dataRef.current).memo) !== null && _b !== void 0 ? _b : (_d.memo = {});\n            (_c = (_e = dataRef.current.memo).item) !== null && _c !== void 0 ? _c : (_e.item = {});\n            return memoize(props, dataRef.current.memo.item);\n        },\n        getRenameInputProps: ({ item, prev }) => {\n            var _a, _b, _c;\n            var _d, _e;\n            const dataRef = item.getDataRef();\n            const props = (_a = prev === null || prev === void 0 ? void 0 : prev()) !== null && _a !== void 0 ? _a : {};\n            (_b = (_d = dataRef.current).memo) !== null && _b !== void 0 ? _b : (_d.memo = {});\n            (_c = (_e = dataRef.current.memo).rename) !== null && _c !== void 0 ? _c : (_e.rename = {});\n            return memoize(props, dataRef.current.memo.rename);\n        },\n    },\n};\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const removeItemsFromParents = (movedItems, onChangeChildren) => __awaiter(void 0, void 0, void 0, function* () {\n    const movedItemsIds = movedItems.map((item) => item.getId());\n    const uniqueParents = [\n        ...new Set(movedItems.map((item) => item.getParent())),\n    ];\n    for (const parent of uniqueParents) {\n        const siblings = parent === null || parent === void 0 ? void 0 : parent.getChildren();\n        if (siblings && parent) {\n            const newChildren = siblings\n                .filter((sibling) => !movedItemsIds.includes(sibling.getId()))\n                .map((i) => i.getId());\n            yield onChangeChildren(parent, newChildren);\n            if (parent && \"updateCachedChildrenIds\" in parent) {\n                parent === null || parent === void 0 ? void 0 : parent.updateCachedChildrenIds(newChildren);\n            }\n        }\n    }\n    movedItems[0].getTree().rebuildTree();\n});\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const insertItemsAtTarget = (itemIds, target, onChangeChildren) => __awaiter(void 0, void 0, void 0, function* () {\n    yield target.item.getTree().waitForItemChildrenLoaded(target.item.getId());\n    const oldChildrenIds = target.item\n        .getTree()\n        .retrieveChildrenIds(target.item.getId());\n    // add moved items to new common parent, if dropped onto parent\n    if (!(\"childIndex\" in target)) {\n        const newChildren = [...oldChildrenIds, ...itemIds];\n        yield onChangeChildren(target.item, newChildren);\n        if (target.item && \"updateCachedChildrenIds\" in target.item) {\n            target.item.updateCachedChildrenIds(newChildren);\n        }\n        target.item.getTree().rebuildTree();\n        return;\n    }\n    // add moved items to new common parent, if dropped between siblings\n    const newChildren = [\n        ...oldChildrenIds.slice(0, target.insertionIndex),\n        ...itemIds,\n        ...oldChildrenIds.slice(target.insertionIndex),\n    ];\n    yield onChangeChildren(target.item, newChildren);\n    if (target.item && \"updateCachedChildrenIds\" in target.item) {\n        target.item.updateCachedChildrenIds(newChildren);\n    }\n    target.item.getTree().rebuildTree();\n});\n", "var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { removeItemsFromParents } from \"./remove-items-from-parents\";\nimport { insertItemsAtTarget } from \"./insert-items-at-target\";\nexport const createOnDropHandler = (onChangeChildren) => (items, target) => __awaiter(void 0, void 0, void 0, function* () {\n    const itemIds = items.map((item) => item.getId());\n    yield removeItemsFromParents(items, onChangeChildren);\n    yield insertItemsAtTarget(itemIds, target, onChangeChildren);\n});\n", "import { throwError } from \"../utilities/errors\";\nconst noop = () => { };\nconst findPrevInstanceMethod = (features, instanceType, methodKey, featureSearchIndex) => {\n    var _a;\n    for (let i = featureSearchIndex; i >= 0; i--) {\n        const feature = features[i];\n        const itemInstanceMethod = (_a = feature[instanceType]) === null || _a === void 0 ? void 0 : _a[methodKey];\n        if (itemInstanceMethod) {\n            return i;\n        }\n    }\n    return null;\n};\nconst invokeInstanceMethod = (features, instanceType, opts, methodKey, featureIndex, args) => {\n    var _a;\n    const prevIndex = findPrevInstanceMethod(features, instanceType, methodKey, featureIndex - 1);\n    const itemInstanceMethod = (_a = features[featureIndex][instanceType]) === null || _a === void 0 ? void 0 : _a[methodKey];\n    return itemInstanceMethod(Object.assign(Object.assign({}, opts), { prev: prevIndex !== null\n            ? (...newArgs) => invokeInstanceMethod(features, instanceType, opts, methodKey, prevIndex, newArgs)\n            : null }), ...args);\n};\nexport const buildProxiedInstance = (features, instanceType, buildOpts) => {\n    // demo with prototypes: https://jsfiddle.net/bgenc58r/\n    const opts = {};\n    const item = new Proxy({}, {\n        has(target, key) {\n            if (typeof key === \"symbol\") {\n                return false;\n            }\n            if (key === \"toJSON\") {\n                return false;\n            }\n            const hasInstanceMethod = findPrevInstanceMethod(features, instanceType, key, features.length - 1);\n            return Boolean(hasInstanceMethod);\n        },\n        get(target, key) {\n            if (typeof key === \"symbol\") {\n                return undefined;\n            }\n            if (key === \"toJSON\") {\n                return {};\n            }\n            return (...args) => {\n                const featureIndex = findPrevInstanceMethod(features, instanceType, key, features.length - 1);\n                if (featureIndex === null) {\n                    throw throwError(`feature missing for method ${key}`);\n                }\n                return invokeInstanceMethod(features, instanceType, opts, key, featureIndex, args);\n            };\n        },\n    });\n    Object.assign(opts, buildOpts(item));\n    return [item, noop];\n};\n"],
  "mappings": "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",
  "names": ["children", "i", "_a", "_b", "instance", "_c", "DragTargetPosition", "AssistiveDndState", "CheckedState", "__awaiter", "_a", "__awaiter", "ItemDropCategory", "PlacementType", "__awaiter", "bb", "__awaiter", "_a", "__awaiter", "__awaiter", "__awaiter", "newChildren", "__awaiter"]
}
